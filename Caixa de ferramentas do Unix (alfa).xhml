<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="pt-br">
<head>                            
  <title>Caixa de Ferramentas do Unix</title>
  <link rel="icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAAAAABoBQAAFgAAACgAAAAQAAAAIAAAAAEACAAAAAAAQAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AOBfLwBbX14AWxgYABg8RwC/g14AGBgYAL9OJAB8KhgAfHFeAOCDUgC/g0cAGCo7AOCDXgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcJCw4ODg4ODgUHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcLCgcHBwcHBwcHBwcHBwcHBwgOBQcHBwcHBwcHBwcHBwcHBAwNBwcHBwcHBwcHBwcHBwcJCwMHBwcHBwcHBwcHBwcCBg0HBwcHBwcHBwcHBwkLAwcHBwcHBwcHBwcHBwcMDQcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=" />
  <meta name="autor" content="Colin Barschel c@cb.vu" />
  <meta name="translator" content="Gabriel da Silveira Costa tocadotux@gmail.com" />
  <meta name="copyright" content="Copyright (c) 2007-2012 Colin Barschel. Alguns direitos reservados sob a licença Creative Commons [Attribution - Share Alike]" />
  <meta name="description" content="Uma coleção de comandos Unix/Linux/BSD e tarefas que são uteis para o trabalho de TI ou para usuários avançados, uma referência compact e prática." />
  <meta name="abstract" content="Unix Toolbox Uma referencia prática e compacta para sysadmins e usuários avançados." />
  <meta name="subject" content="Unix Toolbox revisão 14.4" />
  <meta name="keywords" content="Unix Toolbox, ferramentas Unix, Unix, FreeBSD, Linux, lista de comandos, sysadmin, guia práctico, referncia avançada, tarefas comuns Linux, syntax reminder, howtos, tunels ssh, rsync, certificasos ssl" />
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <style type="text/css">
/* basic CSS common to all media */
html {
    margin: 0;
}
body {
    padding: 0;
    font-family: verdana, arial, sans-serif;
    font-size: 90%;
    counter-reset: chapter section;
}
div.title {
    text-transform: uppercase;
    padding: 1em 0;
    text-align: center;
    font-size: 220%;
    font-weight: bold;
    letter-spacing: .22em;
}
h1, h2, h3 div.title {
    font-family: verdana, sans-serif;
}
h1 {
    text-transform: uppercase;
    font-size: 150%;
    letter-spacing: .15em;
    counter-reset: section;
    string-set: chaptertitle content();
}
h2 {
    font-size: 120%;
    letter-spacing: .10em;
}
h3, h4 {
    font-size: 100%;
    line-height:1em;
    letter-spacing: .07em;
}
h4 {
    font-style: italic;
    font-weight: normal;
    margin: 1em 0 0.5em 0;
}
pre {
    padding: 0.1em 0em 0.1em 1em;
}
div.menu a {
    font-weight: normal;
    text-decoration: none;
}
h1:before {
    content: counter(chapter) " ";
    counter-increment: chapter;
}
h2:before {
    counter-increment: section;
    content: counter(chapter) "." counter(section) " ";
}
/* Not implemented in browsers yet */
a.xref:after { 
    content: " " target-counter(attr(href, url), chapter) "."
    target-counter(attr(href, url), section); 
}
div.changestyle {
    padding-top: 1em;
}

@media screen, handheld {
/* Menu on the right for screen media */
/* including some IE6 hacks */
    body {
        padding: 0;
        margin: 1em 13em 0em 1.5em;
    }	
    html&gt;body {
        margin: 1em 13em 0em 1.5em;
    }
    body&gt;div.menu {
        position: fixed;
    }
    body&gt;div.changestyle {
        position: fixed;
    }
    div.menu { 
        position: absolute;
        z-index: 2;
        width: 10.7em; height: auto;
        top: 0.4em; right: 0.5em; bottom: 0.8em; left: auto;
    }
    div.changestyle {
        font-size: 80%;
        font-weight: normal;
        position: absolute;
        z-index: 2;
        width: 10.7em; height: auto;
        bottom: 0;
    }
    ol.toc, ol.toc li  {
        margin: 0;
        list-style-type: none;
        padding: 0.13em 0;
        text-indent: 0;
        text-align: left;
        line-height: 1.1em;
    }
    p.last {
        padding-top: 5em;
    }
    .fn {
        display: none;
        counter-increment: footnote
    }
}

@media print {
/* layout */
/* Menu as TOC for print */
    body {
        font-size: 88%;
    }	
    div.title {
        padding: 0.5em 0 2em 0;
    }
    div {
        text-align: justify;
    }
    h2 {
        margin-bottom: 0.5em;
    }
    h3 {
        margin-bottom: 0.3em;
    }
    h4 {
        margin-bottom: 0.3em;
    }
    pre {
        font-size: 90%;
        margin: 0.3em 0 0.3em 0;
        padding: 0.2em 0 0.2em 0.4em;
        text-align: left;
        line-height: 115%;
        letter-spacing:-0.03em
    }
    a {
	text-decoration: none;
    }
    p.xrefp {  /* links below h1 headers */
        padding-top: 0;
        margin: -1em 0 1.3em 0;
        page-break-inside: avoid;
        page-break-after: avoid;
    }
    a.xrefp {
        font-weight: normal;
        text-decoration: none;
    }
    ol.toc li  {
        list-style-type: decimal;
        margin: 0;
        padding: 0.25em 0;
    }
    ol.toc  {
        margin: 0 0 0 2.2em;
        list-style-position: outside;
        font-weight: normal;
        list-style-type: decimal;
        padding: 4em 0;
    }
    ol.toc a::after {
        content: leader(' . ') target-counter(attr(href), page);
    }
/*
a.xref:after { 
    content: " [" target-counter(attr(href, url), chapter) "."
    target-counter(attr(href, url), section) " page " 
    target-counter(attr(href, url), page) "]"; 
}
*/
    a.xref:after { 
        content: " (page " target-counter(attr(href, url), page) ")"; 
    }
    a.xrefp:after { 
        content: " (p"target-counter(attr(href, url), page)")"; 
    }
    h1, h2, h3, h4, h5 { 
        page-break-after: avoid;
    }
    div.footerfirst, div.footerlast {
        position: absolute;
        bottom: 0;
    }
    div.main {
        page-break-before: always;
    }
    div.pb {
        page-break-after: always;
    }
    div.changestyle, p.copyright, span.web {
        display: none;
    }
    div#sysinfo {
        margin-top: -1.5em;
    }
    p.last {
        padding-top: 2em;
    }
    .fn {
        display: prince-footnote;
        counter-increment: footnote;
        font: caption;
        font-stretch: normal;
        letter-spacing: normal;
        font-size: xx-small;
        font-style: normal;
        font-weight: normal;
        text-decoration: none;
        vertical-align: super;
    }
    .fn::footnote-call {
        content: counter(footnote);
        font-size: 80%;
        font-style: normal;
        font-weight: normal;
        text-decoration: none;
        vertical-align: super;
        line-height: none
    }
    .fn::footnote-marker {
        list-style-position: inside;
    }
}
@page {
    size: A4 portrait;
    margin: 15mm 12mm 14mm 12mm;
    padding: 0mm 0 5mm 0;
    @footnotes {
	border-top: solid #000040 thin;
	padding-top: 0.22em;
        padding-left: 1.2em;
        font-family: verdana, sans-serif;
    }
    @bottom-center {
        padding: 0 0 5mm 0;
        content: counter(page);
        font-family: verdana, sans-serif;
        font-size: 88%;
    }
    @top {
        padding-top: 5mm;
	content: "— " string(chaptertitle) " —";
        font-family: verdana, sans-serif;
    }
}
@page :first {
    padding: 0;
    @bottom-center {
        content: normal;
    }
    @top {
        content: normal;
    }
}

</style>
<style type="text/css" title="default">
@media screen, handheld, print {
    /* Colors only */
    html {
        background-color: white;
        color: black;
    }
    h1 {
        background-color: #000040;
        color: white;
    }
    h3, h4, div.title, h2, a:link, a:visited, .cmt {
        background-color: transparent;
        color: #000040;
    }
    pre {
        background-color: #F6F6FC;
    }
    pre, code { 
        color: #003300;
    }
    a:hover, .pp {
        color: #D55500;
    }
    a:active {
        color: green;
    }
    .keyword {
        color:#0000FF;
    }
}
@media print {
    /* print only colors */
    pre, code { 
        color: #000;
    }
    a:link, a:visited, .cmt {
        background-color: transparent;
        color: #000060;
    }
}
</style>
<style type="text/css" title="inverse">
@media screen, handheld {
    /* Colors only */
    html {
        background-color: black;
        color: Gainsboro;
    }
    h1 {
        background-color: #ffffcd;
        color: black;
    }
    h3, h4, div.title, h2, a:link, a:visited, .cmt {
        background-color: transparent;
        color: #ffffcd;
    }
    pre {
        background-color: #090903;
    }
    pre, code { 
        color: #ffc3ff;
    }
    a:hover, .pp {
        color: #2aaaff;
    }
    a:active {
        color: orange;
    }
    .keyword {
        color:#ff0000;
    }
}
</style>

  <!-- Script to change the color of the site via the above two styles and
       save the selection into a cookie. The cookie is only generated when
       either the link "white" or "black" is clicked -->

  <!-- This does not word on Safari and Konqueror. Can someone fix it? -->
<script type="text/javascript">
/*<![CDATA[*/

function initCSS() {
  var cookie = readCookie("style");
  var title = cookie ? cookie : "default";
  setActiveStyle(title);
}

function setActiveStyle(title) {
  var j = document.getElementsByTagName("style");
  for(var i=1; i < j.length; i++) { // bypass the first (main) style
    j[i].disabled = true;
    if(j[i].getAttribute("title") == title) {
        j[i].disabled = false;
    }
  }
}

/* Only create a cookie when the link is clicked */
function setActiveStyleLink(title) {
  setActiveStyle(title)
  createCookie("style", title, 365);
}

function createCookie(name,value,days) {
  if (days) {
    var date = new Date();
    date.setTime(date.getTime()+(days*24*60*60*1000));
    var expires = "; expires="+date.toGMTString();
  }
  else expires = "";
  document.cookie = name+"="+value+expires+"; path=/";
}

function readCookie(name) {
  var nameEQ = name + "=";
  var ca = document.cookie.split(';');
  for(var i=0;i < ca.length;i++) {
    var c = ca[i];
    while (c.charAt(0)==' ') c = c.substring(1,c.length);
    if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
  }
  return null;
}

window.onload = initCSS();

/*]]>*/
</script>
</head>
<body>
<div class="title">Unix Toolbox</div>
<div class="abstract">
Esse documento é uma coleção de comandos Unix/Linux/BSD e de tarefas que são uteis para trabalho em TI ou usuários avançados. Esse é um guia prático com explicações concisas, embora o leitor deve saber o que está fazendo.<br /><br />
</div>
<div class="footerfirst">
Unix Toolbox revisão 14.4<br />
A ultima versão desse documento pode ser encontrado em <a href="http://cb.vu/unixtoolbox.xhtml">http://cb.vu/unixtoolbox.xhtml</a>. Substitua .xhtml no link com <a href="http://cb.vu/unixtoolbox.pdf">.pdf</a> para a versão PDF e com <a href="http://cb.vu/unixtoolbox.book.pdf">.book.pdf</a> para a versão folheto. Em uma impressora duplex o folheto criará um pequeno livro pronto para encadernar. <span class="web">Essa página XHTML pode ser convertida para um bom documento PDF com uma aplicação complacente CSS3 (veja o <a class="xref" href="https://github.com/tocadotux/caixaDeFerramentasDoUnix/blob/master/Caixa%20de%20ferramentas%20do%20Unix%20(alfa).xhml">script exemplo</a>).</span> Veja também a <a href="http://cb.vu/unixtoolbox">página sobre</a>.<br />
Reportes de erros e comentários são muito bem vindos - <a href="mailto:c\at\cb.vu">c@cb.vu</a> Colin Barschel.
<p class="copyright">© <a href="mailto:c_at_cb.vu">Colin Barschel</a> 2007-2012. <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Alguns direitos reservados sob a licença</a>.
</p>
</div> 
<!-- A tabela de conteúdo é exibida como um menu fixado verticalmente à direita quando visualizado em um navegador. Quando impresso TOC é exibido na página incial como uma tabela clássica de conteúdo como números -->
<div class="menu">
<ol class="toc">
  <li><a href="#sysinfo">Sistema</a></li>
  <li><a href="#processes">Processos</a></li>
  <li><a href="#filesystem">Sistema de Arquivos</a></li>
  <li><a href="#network">Rede</a></li>
  <li><a href="#ssh">SSH SCP</a></li>
  <li><a href="#vpn">VPN com SSH</a></li>
  <li><a href="#rsync">RSYNC</a></li>
  <li><a href="#sudo">SUDO</a></li>
  <li><a href="#crypt">Arquivos Encriptados</a></li>
  <li><a href="#cryptpart">Partições Encriptadas</a></li>
  <li><a href="#certs">Certificados SSL</a></li>
  <li><a href="#cvs">CVS</a></li>
  <li><a href="#svn">SVN</a></li>
  <li><a href="#other">Comando Úteis</a></li>
  <li><a href="#software">Instalar Software</a></li>
  <li><a href="#convert">Converter Mídia</a></li>
  <li><a href="#printing">Impressão</a></li>
  <li><a href="#databases">Banco de Dados</a></li>
  <li><a href="#quota">Quota de Disco</a></li>
  <li><a href="#shells">Shells</a></li>
  <li><a href="#scripting">Scripting</a></li>
  <li><a href="#programming">Programar</a></li>
  <li><a href="#onlinehelp">Ajuda Online</a></li>
</ol>
<br />
<div class="changestyle"> <!-- small icons for black and white view. SVG is embedded -->
<a href="http://cb.vu/unixtoolbox.xhtml#" onclick="setActiveStyleLink(&apos;default&apos;); return false;">
<svg:svg width="15" height="10" viewBox="0 0 310 210">
<svg:rect x="5" y="5" width="300" height="200" style="stroke:black;stroke-width:7;fill:white" />
<svg:line x1="25" y1="55" x2="280" y2="55" style="stroke:black;stroke-width:7;" />
<svg:line x1="25" y1="100" x2="280" y2="100" style="stroke:black;stroke-width:7;" />
<svg:line x1="25" y1="148" x2="280" y2="148" style="stroke:black;stroke-width:7;" />
</svg:svg> white
</a>
<a href="http://cb.vu/unixtoolbox.xhtml#" onclick="setActiveStyleLink(&apos;inverse&apos;); return false;">
<svg:svg width="15" height="10" viewBox="0 0 310 210">
<svg:rect x="5" y="5" width="300" height="200" style="stroke:white;stroke-width:7;fill:black" />
<svg:line x1="25" y1="55" x2="280" y2="55" style="stroke:white;stroke-width:10;" />
<svg:line x1="25" y1="100" x2="280" y2="100" style="stroke:white;stroke-width:10;" />
<svg:line x1="25" y1="148" x2="280" y2="148" style="stroke:white;stroke-width:10;" />
</svg:svg> black
</a>
</div> <!-- end change style links -->
</div> <!-- end menu -->
<div class="pb" />
 <!-- <div class="main"> Every chapter is inside a div block for easy XML parsing -->
<div id="sysinfo"><h1><a>Sistema</a></h1>
<p class="xrefp"><a class="xrefp" href="#hardwareinfo">Hardware</a> | <a class="xrefp" href="#loadstats">Estatísticas</a> | <a class="xrefp" href="#users">Usuários</a> | <a class="xrefp" href="#limits">Limites</a> | <a class="xrefp" href="#runlevels">Runlevels</a> | <a class="xrefp" href="#resetpasswd">Senha de root</a> | <a class="xrefp" href="#compilekernel">Compilar o kernel</a> | <a class="xrefp" href="#grub">Concertar o grub</a> | <a class="xrefp" href="#sysmisc">Outros</a></p>
Rodando o kernel e informações do sistema
<pre># uname -a                           <span class="cmt"># Obter versão do kernel (e versão do BSD também)</span>
# lsb_release -a                     <span class="cmt"># Informação completa de lançamento de qualquer distribuição LSB</span>
# cat /etc/SuSE-release              <span class="cmt"># Obter versão do SuSE</span>
# cat /etc/debian_version            <span class="cmt"># Obter versão do Debian</span>
</pre>
Utilize /etc/<code>DISTR</code>-release com <code>DISTR=</code> lsb (Ubuntu), redhat, gentoo, mandrake, sun (Solaris), e assim por diante. veja também <code>/etc/issue</code>.
<pre># uptime                             <span class="cmt"># Exibir a quanto tempo o sistema está rodando + carga</span>
# hostname                           <span class="cmt"># host name do sistema</span>
# hostname -i                        <span class="cmt"># Exibir o endereço de IP do host. (somente para Linux)</span>
# man hier                           <span class="cmt"># Descrição da hierarquia do sistema de arquivo</span>
# last reboot                        <span class="cmt"># Exibir histórico de reboot do sistema</span>
</pre>
<h2 id="hardwareinfo">Informações de Hardware</h2>
Hardware detectado pelo kernel
<pre># dmesg                              <span class="cmt"># Hardware detectado e mensagens de boot</span>
# lsdev                              <span class="cmt"># informação a respeito do hardware instalado</span>
# dd if=/dev/mem bs=1k skip=768 count=256 2&gt;/dev/null | strings -n 8 <span class="cmt"># Lê BIOS</span>
</pre>
<h3>Linux</h3>
<pre># cat /proc/cpuinfo                  <span class="cmt"># Modelo do CPU</span>
# cat /proc/meminfo                  <span class="cmt"># Memória do Hardwarey</span>
# grep MemTotal /proc/meminfo        <span class="cmt"># Exibir a memória física</span>
# watch -n1 'cat /proc/interrupts'   <span class="cmt"># Observar interrupções alteraveis continuamente</span>
# free -m                            <span class="cmt"># Memória utilizada e livre (-m para MB)</span>
# cat /proc/devices                  <span class="cmt"># dispositivos configurados</span>
# lspci -tv                          <span class="cmt"># Exibir dispositivos PCI</span>
# lsusb -tv                          <span class="cmt"># Exibir dispositivos USB</span>
# lshal                              <span class="cmt"># Exibir uma lista de todos os dispositivos com suas propriedades</span>
# dmidecode                          <span class="cmt"># Exibir DMI/SMBIOS: hw info da BIOS</span>
</pre>
<h3>FreeBSD</h3>
<pre># sysctl hw.model                    <span class="cmt"># Modelo do CPU</span>
# sysctl hw                          <span class="cmt"># Dá um monte de informações de hardware</span>
# sysctl hw.ncpu                     <span class="cmt"># número de CPUs ativos instalados</span>
# sysctl vm                          <span class="cmt"># Uso de memory</span>
# sysctl hw.realmem                  <span class="cmt"># Memória do hardware</span>
# sysctl -a | grep mem               <span class="cmt"># Configurações de memória do kernel e informações</span>
# sysctl dev                         <span class="cmt"># Dispositivos Configurados</span>
# pciconf -l -cv                     <span class="cmt"># Exibir dispositivos PCI</span>
# usbdevs -v                         <span class="cmt"># Exibir dispositivos USB</span>
# atacontrol list                    <span class="cmt"># Exibir dispositivos ATA</span>
# camcontrol devlist -v              <span class="cmt"># Exibir dispositivos SCSI</span>
</pre>
<h2 id="loadstats">Carga, estatísticas and mensagens</h2>
Os comandos a seguir são uteis para descobrir o que está acontecendo no sistema.
<pre># top                                <span class="cmt"># exibe e atualiza o top dos processos do cpu</span>
# mpstat 1                           <span class="cmt"># exibe estatísticas relacionadas ao processador</span>
# vmstat 2                           <span class="cmt"># exibe estatísticas da memória virtual</span>
# iostat 2                           <span class="cmt"># exibe estatíticas de I/O (intervalos de 2 s)</span>
# systat -vmstat 1                   <span class="cmt"># resumo estatíticas de sistema BSD (intervalos de 1 s)</span>
# systat -tcp 1                      <span class="cmt"># conexões tcp BSD (tente também -ip)</span>
# systat -netstat 1                  <span class="cmt"># conexẽos de rede de ativa BSD</span>
# systat -ifstat 1                   <span class="cmt"># tráfego de rede BSD pelas interfaces ativas</span>
# systat -iostat 1                   <span class="cmt"># CPU BSD e rendimento de disco</span>
# ipcs -a                            <span class="cmt"># informação de interprocessos no System</span>
# tail -n 500 /var/log/messages      <span class="cmt"># Ultimas 500 mensagens kernel/syslog</span>
# tail /var/log/warn                 <span class="cmt"># Mensagems de aviso do sistem; veja syslog.conf</span>
</pre>
<h2 id="users">Usuários</h2>
<pre># id                                 <span class="cmt"># Exibe id do usuário ativo com login e group</span>
# last                               <span class="cmt"># Exibe os ultimos logins no sistem</span>
# who                                <span class="cmt"># Exibe quem está logado no sistema</span>
# groupadd admin                     <span class="cmt"># Adiciona grupo "admin" e usuário colin (Linux/Solaris)</span>
# useradd -c "Colin Barschel" -g admin -m colin
# usermod -a -G &lt;group&gt; &lt;user&gt;       <span class="cmt"># Adiciona usuário existente ao grupo (Debian)</span>
# groupmod -A &lt;user&gt; &lt;group&gt;         <span class="cmt"># Adiciona usuário existente ao grupo (SuSE)</span>
# userdel colin                      <span class="cmt"># Remove o usuário colin (Linux/Solaris)</span>
# adduser joe                        <span class="cmt"># FreeBSD adicionar usuário joe (interativo)</span>
# rmuser joe                         <span class="cmt"># FreeBSD remove usuário joe (interativo)</span>
# pw groupadd admin                  <span class="cmt"># Utilize pw no FreeBSD</span>
# pw groupmod admin -m newmember     <span class="cmt"># Adicione um novo menbro ao grupo</span>
# pw useradd colin -c "Colin Barschel" -g admin -m -s /bin/tcsh 
# pw userdel colin; pw groupdel admin
</pre>
Senhas criptografadas ficam armazenadas em /etc/shadow no Linux e Solaris e /etc/master.passwd no FreeBSD. Se o master.passwd for modificado manualmente (dizê-lo para remover uma senha), execute o <code># pwd_mkdb -p master.passwd</code> para reconstruir a base de dados.<br /><br />
Para impedir logins temporariamente no sistema (para todos os usuários, menos para o root) utilize o nologin. A mensagem em nologin será exibida (pode não funcionar com as chaves pré-compartilhadas do ssh).
<pre># echo "Desculpe, sem login no momento" &gt; /etc/nologin       <span class="cmt"># (Linux)</span>
# echo "Desculpe, sem login no momento" &gt; /var/run/nologin   <span class="cmt"># (FreeBSD)</span>
</pre>

<h2 id="limites">Limites</h2>
Algumas aplicações requerem limites mais altos em arquivos e sockets abertos (como um servidor proxy
, banco de dados). Os limites padrões são normalmente muito baixos.
<h3>Linux</h3>
<h4>Por shell/script</h4>
Os limites do shell são governados pelo <code>ulimit</code>. O status é verificado
com o <code>ulimit -a</code>. Por exemplo, para alterar o limite dos arquivos de
1024 para 10240, faça:
<pre># ulimit -n 10240                    <span class="cmt"># Isso é válido somente dentro do shell</span>
</pre>
O comando <code>ulimit</code> pode ser utilizado em um script para alterar os limites para o script somente.

<h4>Por usuário/processo</h4>
Login, usuários e aplicações podem ser configurados em <code>/etc/security/limits.conf</code>. por exemplo:
<pre># cat /etc/security/limits.conf
*   hard    nproc   250              <span class="cmt"># Limite de processos por usuário</span>
asterisk hard nofile 409600          <span class="cmt"># Limite de arquivos abertos por aplicação</span>
</pre>
<h4>Sistema</h4>
Limites do kernel são configurados com o sysctl. Limites permanentes são configurados em <code>/etc/sysctl.conf</code>.
<pre># sysctl -a                          <span class="cmt"># Visualizar todos os limites do sistema</span>
# sysctl fs.file-max                 <span class="cmt"># Visualizar limite máximo de arquivos abertos</span>
# sysctl fs.file-max=102400          <span class="cmt"># Alterar limite de máximo de arquivos abertos</span>
# echo "1024 50000" &gt; /proc/sys/net/ipv4/ip_local_port_range  <span class="cmt"># alcande de porta</span>
# cat /etc/sysctl.conf
fs.file-max=102400                   <span class="cmt"># Entrada permanetre em sysctl.conf</span>
# cat /proc/sys/fs/file-nr           <span class="cmt"># Quantos descritores de arquivo estão em uso</span>
</pre>

<h3>FreeBSD</h3>
<h4>Por shell/script</h4>
Utilize o comando <code>limits</code> no csh ou no tcsh ou como no Linux, utilize <code>ulimit</code> em um sh ou bash shell.
<h4>Por user/processo</h4>
Os limites padrões no login são configuradors em <code>/etc/login.conf</code>. Um valor ilimitdor é ainda assim limitado pelo valor máximo do sistema.
<h4>Sistema</h4>
Limites do kernel também são configurados com o sysctl. Limites permanentes são configurados em <code>/etc/sysctl.conf</code> ou <code>/boot/loader.conf</code>. A syntax é a mesma como em Linux, mas as chaves são diferentes.
<pre># sysctl -a                          <span class="cmt"># Visualizar todos os limites do sistema</span>
# sysctl kern.maxfiles=XXXX          <span class="cmt"># Número máximo de descrições de arquivo</span>
kern.ipc.nmbclusters=32768           <span class="cmt"># Entrada permanente em /etc/sysctl.conf</span>
kern.maxfiles=65536                  <span class="cmt"># Valores tipicos para Squid</span>
kern.maxfilesperproc=32768
kern.ipc.somaxconn=8192              <span class="cmt"># Fila de TCP. Melhor para apache/sendmail</span>
# sysctl kern.openfiles              <span class="cmt"># Quantas descrições de arquivo estão em uso</span>
# sysctl kern.ipc.numopensockets     <span class="cmt"># Qantos sockets abertos estão em uso</span>
# sysctl net.inet.ip.portrange.last=50000 <span class="cmt"># O padrão é 1024-5000</span>
# netstat -m                         <span class="cmt"># Estatísticas de buffers de memória de rede</span>
</pre>
Veja o <a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/configtuning-kernel-limits.html">Capítulo 11 do FreeBSD handbook</a><span class="fn">http://www.freebsd.org/handbook/configtuning-kernel-limits.html</span> para mais detalhes. E também <a href="http://serverfault.com/questions/64356/freebsd-performance-tuning-sysctls-loader-conf-kernel">FreeBSD performance tuning</a><span class="fn">http://serverfault.com/questions/64356/freebsd-performance-tuning-sysctls-loader-conf-kernel</span>

<h3>Solaris</h3>
Os valores a seguir em <code>/etc/system</code> aumentarão o descritores máximo de arquivo por proc:
<pre>set rlim_fd_max = 4096               <span class="cmt"># Limite rígido nos descritores de arquivo para um single single proc</span>
set rlim_fd_cur = 1024               <span class="cmt"># Limite leve nos descritores de arquivo para um single proc</span>
</pre>

<h2 id="runlevels">Runlevels (níveis de execução)</h2>
<h3>Linux</h3>
Uma vez inicializado, o kernel inicia o <code>init</code> o qual então inicia <code>rc</code> o qual inicia todos os scripts pertencentes á um runlevel. Os scripts são armazenados em /etc/init.d e são linkados dentro de /etc/rc.d/rcN.d com N número do runlevel.<br />
O runlevel padrão está configurado em /etc/inittab. É normalmente o 3 ou o 5:
<pre># grep default: /etc/inittab                                         
id:3:initdefault:
</pre>
O The runlevel atual pode ser alterado com o <code>init</code>. Por exemplo, para ir do 3 para o 5:
<pre># init 5                             <span class="cmt"># Entra o runlevel 5</span></pre>
<ul style="list-style-type:none; page-break-inside:avoid;">
  <li>0       Shutdown and halt(encerrar e desligar)</li>
  <li>1       Modo Single-User (também S: Não inicia as daemons, ou seja, serviços)</li>
  <li>2       Multi-user sem rede</li>
  <li>3       Multi-user com rede</li>
  <li>5       Multi-user com X</li>
  <li>6       Reboot</li>
</ul>
(Nota do tradutor: Não foi mencionado o valor de número 4, porém não é aconselhado utilizá-lo, pois esse valor não tem definição por se tratar de uso somente para propósitos especiais.)
<ul>
</ul>
Use <code>chkconfig</code> para configurar os programas que serão incializados ao boot em um runlevel.
<pre># chkconfig --list                   <span class="cmt"># Listar todos os scripts init</span>
# chkconfig --list sshd              <span class="cmt"># Reportar o status do sshd</span>
# chkconfig sshd --level 35 on       <span class="cmt"># Configuar o e sshd para os nívies 3 e 5</span>
# chkconfig sshd off                 <span class="cmt"># Disabilitar o sshd para todos os runlevels</span>
</pre>
Debian e distribuições basadas em Debian como o Ubuntu ou o Knoppix utilizam o comando <code>update-rc.d</code> para gerenciar os scripts de runlevels. O padrão é iniciar em 2,3,4 and 5 e encerrar em 0,1 e 6.
<pre># update-rc.d sshd defaults          <span class="cmt"># Ativar o sshd com os runlevels padrões</span>
# update-rc.d sshd start 20 2 3 4 5 . stop 20 0 1 6 .  <span class="cmt"># Com argumentos explícitos</span>
# update-rc.d -f sshd remove         <span class="cmt"># Disabilita o sshd para todos os runlevels</span>
# shutdown -h now (or # poweroff)    <span class="cmt"># Ecerra e desliga o sistema</span>
</pre>

<h3>FreeBSD</h3>
A aproximação da inicialização do BSD é diferente do SysV, não há runlevels. O estado final do boot (single user, com ou sem X) é configurado em <code>/etc/ttys</code>. Todos os scripts do OS ficam localizados em <code>/etc/rc.d/</code> e em <code>/usr/local/etc/rc.d/</code> para aplicações de terceiros (third-party). A ativação do serviço é configurada em <code>/etc/rc.conf</code> e <code>/etc/rc.conf.local</code>. O comportameneto padrão é configurado em <code>/etc/defaults/rc.conf</code>. O scripts respondem ao menos a start|stop|status.
<pre># /etc/rc.d/sshd status
sshd is running as pid 552.
# shutdown now                       <span class="cmt"># Vá para o modo single-user</span>
# exit                               <span class="cmt"># Volta ao modo multi-user</span>
# shutdown -p now                    <span class="cmt"># Encerre e desligue o sistema</span>
# shutdown -r now                    <span class="cmt"># Reiniciar</span>
</pre>
O processo <code>init</code> pode também ser usado para alcançar um dos níveis estados de seguintes. Por exemplo <code># init 6</code> para reboot.
<ul style="list-style-type:none; page-break-inside:avoid;">
  <li>0       parar (Halt) e desligar (power off) (signal <code>USR2</code>)</li>
  <li>1       Vai para modo single-user (signal <code>TERM</code>)</li>
  <li>6       Reinicia a máquina (signal <code>INT</code>)</li>
  <li>c       Bloqueia logins futuros (signal <code>TSTP</code>)</li>
  <li>q       Reverificar o ttys(5) file (signal <code>HUP</code>)</li>
</ul>
<h3>Windows</h3>
Inicia e para um serviço ou com o <code>service name</code> ou com <code>"service description"</code> (exibe o Painel de Controle de Serviços) como se segue:
<pre>net stop WSearch
net start WSearch                    <span class="cmt"># inicia serviçode busca</span>
net stop "Windows Search"
net start "Windows Search"           <span class="cmt"># mesmo que acima utilizando o descr.</span>
</pre>
<h2 id="resetpasswd">Reconfigurar a senha de root</h2>
<h3>Método Linux 1</h3>
Ao carregamento de boot [boot loader (lilo or grub)], entre a opção de boot a seguir:
<pre>init=/bin/sh</pre>
O kernel montará a partição root e <code>init</code> iniciará o bourne shell
ao inves de <code>rc</code> e então um runlevel. Utilize o comando <code>passwd</code> no prompt e altere a senha e então reinicie. Esqueca o modo single user como se precisasse da senha para isso.<br />
Se, depois de inicializar, a partição root estiver montada em somente leitura (read only), remonte em rw:
<pre># mount -o remount,rw /
# passwd                             <span class="cmt"># ou exclua a senha do root (/etc/shadow)</span>
# sync; mount -o remount,ro /        <span class="cmt"># sincroniza antes para remontar em somente leitura (read only)</span>
# reboot
</pre> 
<h3>Método FreeBSD 1</h3>
No FreeBSD, inicialize em modo  single user, remonte / rw e utilize passwd. Você oide selcionar o modo single user no menu de boot (opção 4) que é exibido por  10 segundos ao inicio. o modo single user lhe dará um shell root na partição /.
<pre># mount -u /; mount -a               <span class="cmt"># montará / rw</span>
# passwd
# reboot
</pre>

<h3>Método 2: Unixes e FreeBSD e Linux</h3>
Outros Unixes podem não deixar você ir embora com um simples truque init. A solução é montar a partição root de um outro OS (como um CD de recuperação) e alterar a senha no disco.
<ul>
  <li>Boot um live CD ou CD de instalação em modo de recuperação que lhe dará um shell.</li>
  <li>Encontre a partição root com o fdisk e.g. fdisk /dev/sda (Nota do tradutor: Bom, eu em particular prefiro utilizar o fdisk -l antes disso. Assim consegue identificar quais os discos caso não saiba qual é. Muito cuidado com a manipulação do fdisk)</li>
  <li>Monte-o e use o chroot:</li>
</ul>
<pre># mount -o rw /dev/ad4s3a /mnt
# chroot /mnt                        <span class="cmt"># chroot no /mnt</span>
# passwd
# reboot
</pre>

<h2 id="kernelmodules">módulos do kernel</h2>
<h3>Linux</h3>
<pre># lsmod                              <span class="cmt"># Listar todos os módulos carregados no kernel</span>
# modprobe isdn                      <span class="cmt"># Para carregar um módulo (aqui no exemplo, isdn)</span>
</pre>
<h3>FreeBSD</h3>
<pre># kldstat                            <span class="cmt"># Listar todos os módulos carregados no kernel</span>
# kldload crypto                     <span class="cmt"># Para carregar um móudlo (aqui no caso, crypto)</span>
</pre>
<h2 id="compilekernel">Compilar o Kernel</h2>
<h3>Linux</h3>
<pre># cd /usr/src/linux
# make mrproper                      <span class="cmt"># Limpe tudo, incluindo arquivos de configuração</span>
# make oldconfig                     <span class="cmt"># Re-utilize o antigo .config se existente</span>
# make menuconfig                    <span class="cmt"># ou xconfig (Qt) ou gconfig (GTK)</span>
# make                               <span class="cmt"># Crie uma imagen do kernel  comprimido</span>
# make modules                       <span class="cmt"># Compile os modulos</span>
# make modules_install               <span class="cmt"># Instale os modulos</span>
# make install                       <span class="cmt"># Instale o kernel</span>
# reboot
</pre>
<h3>FreeBSD</h3>
Opcionalmente atualize a arvore fonte (source tree) (no <code>/usr/src</code>) com o csup (como do FreeBSD 6.2 ou mais recentes):
<pre># csup &lt;supfile&gt;</pre>
Eu utilizo o seguinte supfile:
<pre>*default host=cvsup5.FreeBSD.org  # www.freebsd.org/handbook/cvsup.html#CVSUP-MIRRORS
*default prefix=/usr 
*default base=/var/db
*default release=cvs delete tag=RELENG_7
src-all
</pre>
Para modificar e reconstruir o kernel, copie o arquivo de configuração genérica para um novo nome e edite-o como necessário (você pode também editar o arquivo <code>GENERIC</code> diretamente). Para reiniciar a construção depois da interrupção, adicione a opção <code>NO_CLEAN=YES</code> para fazer o comando evitar que limpe os objetos já construidos.
<pre># cd /usr/src/sys/i386/conf/
# cp GENERIC MYKERNEL
# cd /usr/src
# make buildkernel KERNCONF=MYKERNEL
# make installkernel KERNCONF=MYKERNEL
</pre>
Para reconstruir o OS por completo:
<pre># make buildworld                    <span class="cmt"># Construa o OS por completo, mas não o kernel</span>
# make buildkernel                   <span class="cmt"># Utilize KERNCONF como acima se apropriado</span>
# make installkernel
# reboot
# mergemaster -p                     <span class="cmt"># Compare somente arquivos conhecidos por serem essenciais</span>
# make installworld
# mergemaster -i -U                  <span class="cmt"># Atualizar todas as configurações e outros arquivos</span>
# reboot
</pre>
Para pequenas mudanças na fonte você pode utilizar NO_CLEAN=yes para evitar reconstruir toda a arvore (tree).
<pre># make buildworld NO_CLEAN=yes       <span class="cmt"># Não exclua os objetos antigos</span>
# make buildkernel KERNCONF=MYKERNEL NO_CLEAN=yes
</pre>

<h2 id="grub">Reparar (concertar) o grub</h2>
Então você quebrou o grub? Inicie (boot) a partir de um live cd, [encontre sua partição linux sob <code>/dev</code> e utilize <code>fdisk</code> para encontrara partição Linux] monte a partição linux, adicione /proc e /dev e utilize <code>grub-install /dev/xyz</code>. Suponha que o linux repousa no <code>/dev/sda6</code>:
<pre># mount /dev/sda6 /mnt               <span class="cmt"># monte a partição linux em /mnt</span>
# mount --bind /proc /mnt/proc       <span class="cmt"># monte o subsistema dentro de /mnt</span>
# mount --bind /dev /mnt/dev         <span class="cmt"># monte os dispositivos dentro de /mnt</span>
# chroot /mnt                        <span class="cmt"># altere o root para a partição linux</span>
# grub-install /dev/sda              <span class="cmt"># reinstale o grub com suas configurações antigas</span>
</pre>
<h2 id="sysmisc">Misc</h2>
Desabilitar a memória virtual do OSX (repita com o <code>load</code> para re-abilitar). Sistema mais rapido, mas um pouco arriscado.
<pre># sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.dynamic_pager.plist
# sleep 3600; pmset sleepnow           <span class="cmt"># vá para o modo standby dentro de uma hora (OSX)</span>
# defaults write -g com.apple.mouse.scaling -float 8
                                     <span class="cmt"># aceleração de mouse do OSX (utilize p -1 para reverter)</span>
</pre>
</div>

<div id="processes"><h1><a>Processos</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#ps">Listing</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#nice">Priority</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#bgfg">Background/Foreground</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#top">Top</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#kill">Kill</a></p>
<h2 id="ps">Listar e PIDs</h2>
Cada processo possui número unico, o chamado PID. Uma lista de todos os processos em execução é exibido com o <code>ps</code>.
<pre># ps -auxefw                         <span class="cmt"># Lista extensiva de todos os processos em execução</span></pre>
Contudo o uso mais tipico é com um pipe ou com <code>pgrep</code> (para o OS X instale <code>proctools</code> a partir do <a class="xref" href="http://cb.vu/unixtoolbox.xhtml#macports">MacPorts</a>):
<pre># ps axww | grep cron
  586  ??  Is     0:01.48 /usr/sbin/cron -s
# ps axjf                            <span class="cmt"># Todos os processos em um formato de arvore (Linux)</span>
# ps aux | grep 'ss[h]'              <span class="cmt"># Encotre todos os pids ssh sem o pid do grep</span>
# pgrep -l sshd                      <span class="cmt"># Encontre os PIDs dos processos por (parte do) nome</span>
# echo $$                            <span class="cmt"># O PID do seu shell</span>
# fuser -va 22/tcp                   <span class="cmt"># Lista de processos utilizando a porta 22 (Linux)</span>
# pmap PID                           <span class="cmt"># Mapa de memória do processo (cace o vazamento de memória) (Linux)</span>
# fuser -va /home                    <span class="cmt"># Listar processos accessando a partição /home</span>
# strace df                          <span class="cmt"># Traçar chamadas e sinais do sistema</span>
# truss df                           <span class="cmt"># O mesmo acima no FreeBSD/Solaris/Unixware</span>
</pre>

<h2 id="nice">Prioridade</h2>
Altere a prioridade de um processo em execução com o <code>renice</code>. <b>Números negativos tem uma prioridade mais alta</b>, o mais baixo é -20 e "nice" tem um valor positivo.
<pre># renice -5 586                      <span class="cmt"># prioridade mais forte</span>
586: old priority 0, new priority -5
</pre>
Inicie o processo com uma prioridade definida com <code>nice</code>. Positivo é"nice" ou fraco, negativo é prioridade de agendamento forte. certifique-se de que você sabe se <code>/usr/bin/nice</code> ou o shell built-in é utilizado (verifique com o <code># which nice</code>).
<pre># nice -n -5 top                     <span class="cmt"># prioridade mais forte (/usr/bin/nice)</span>
# nice -n 5 top                      <span class="cmt"># Prioridade mais fraca(/usr/bin/nice)</span>
# nice +5 top                        <span class="cmt"># tcsh builtin nice (o mesmo que acima!)</span>
</pre>
Enquanto nice altera o agedador do CPU (scheduler), um outro comando util <code>ionice</code> agendará o IO de disco. Isso é muto util para aplicações intensivas de IO (entrada e saída)(exemplo: compilar). Você pode selecionar uma classe [inativo (idle) - melhor esforço (best effort) - tempo real (real time)], a página de manual (man page) é curta e bem explicada.
<pre># ionice c3 -p123                    <span class="cmt"># configura a classe inativa (idle class) para o pid 123 (somente em Linux)</span>
# ionice -c2 -n0 firefox             <span class="cmt"># Roda o firefox com melhor empenho (best effort) e alta prioridade</span>
# ionice -c3 -p$$                    <span class="cmt"># Configura a sheel atual para prioridade inativa</span>
</pre>
O ultimo comando é muito util para compilar (ou debugar) um grande projeto. Todo comando carregado a partir do shell terá uma prioridade lover. <code>$$</code> é o seu pid shell (tente echo $$).<br />
Os FreeBSD utilizam <code>idprio/rtprio</code> (0 = max priority, 31 = most idle):
<pre># idprio 31 make                     <span class="cmt"># compila em baixa prioridade</span>
# idprio 31 -1234                    <span class="cmt"># configura o PID 1234 com baixa prioridade</span>
# idprio -t -1234                    <span class="cmt"># -t remove qualquer real time/idle priority</span>
</pre>
<h2 id="bgfg">Plano de fundo ou plano forntal (Background/Foreground)</h2>
Quando iniciado a partir de um shell, processos podem ser trazidos em plano de fundo (background) e devolta para o plano frotal (foreground) com [Ctrl]-[Z] (^Z), <code>bg</code> e <code>fg</code>. Listar os processos com o <code>jobs</code>. Quando necessário destaca a partir de um terminal com o <code>disown</code>.
<pre># ping cb.vu &gt; ping.log
^Z                                   <span class="cmt"># ping está suspense (parado) com o [Ctrl]-[Z]</span> 
# bg                                 <span class="cmt"># Coloca em plano de fundo e continua rodando</span>
# jobs -l                            <span class="cmt"># Lista processos em plano de fundo</span>
[1]  - 36232 Running                       ping cb.vu &gt; ping.log
[2]  + 36233 Suspended (tty output)        top
# fg %2                              <span class="cmt"># Traz processo  2 devolta para plano frontal</span>
</pre>
<pre># make                               <span class="cmt"># Inicia um serviço long de compilação mas necessita deixar o terminal</span>
^Z                                   <span class="cmt"># suspenso (stopped) com [Ctrl]-[Z]</span> 
# bg                                 <span class="cmt"># Coloca em plano de fundo e continua rodando</span>
# disown -h %1                       <span class="cmt"># destaca processo a partir do terminal, não será morto no logout</span>
</pre>
Sem caminho a frente para reanexar o processo para um novo terminal, tente <a href="https://github.com/nelhage/reptyr">reptyr</a> (Linux).<br />
Utilize <code>nohup</code> para iniciar um processo na qual tem que continuar executando quando o shell for fechado (imune a hangups).
<pre># nohup ping -i 60 &gt; ping.log &amp;
</pre>

<h2 id="top">Top</h2>
O programa <code>top</code> exibe informações de processos em execução. Veja também o programa <code>htop</code> a partir de htop.sourceforge.net (uma versão mais poderosa do top) que roda em Linux e em FreeBSD (<code>ports/sysutils/htop/</code>). Enquando o top estiver rodando pressione a tecla h para uam visão global de ajuda (help). Teclas uteis são:
<ul>
  <li><b>u [user name]</b> para exibir somente os processos pertinetes ao usuário. Utilize + ou em barco para ver todos os usuários</li>
  <li><b>k [pid]</b> Matar os processos com o pid.</li>
  <li><b>1</b> para exibir todas as estatíticas dos processadores (somente em Linux)</li>
   <li><b>R</b> Alterna o tipo de normal/reversa.</li>
</ul>
<h2 id="kill">Sigais/Kill</h2>
Terminata ou envia um sinal com <code>kill</code> ou <code>killall</code>.
<pre># ping -i 60 cb.vu &gt; ping.log &amp;
[1] 4712
# kill -s TERM 4712                  <span class="cmt"># O mesmo que kill -15 4712</span>
# killall -1 httpd                   <span class="cmt"># Kill HUP nos processos por nome exato</span>
# pkill -9 http                      <span class="cmt"># Kill TERM nos processos por (parte do) nome</span>
# pkill -TERM -u www                 <span class="cmt"># Kill TERM nos processos possuídos por www</span>
# fuser -k -TERM -m /home            <span class="cmt"># mata todos os processos acessando /home (para desmontar)</span>
</pre>
Sinais importantessão:
<ul style="list-style-type: none;">
  <li>1       <code>HUP</code> (hang up)</li>
  <li>2       <code>INT</code> (interrupt)</li>
  <li>3       <code>QUIT</code> (quit)</li>
  <li>9       <code>KILL</code> (non-catchable, non-ignorable kill)</li>
  <li>15     <code>TERM</code> (software termination signal)</li>
</ul>

</div>

<div id="fileystem"><h1><a>Sistema de arquivos</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#diskinfo">Informação de disco</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#fsboot">Boot</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#mountpoints">Uso de disco</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#filesstat">Arquivos abertos</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#mountcd">Montar/remontar</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#mountsmb">Montar o SMB</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#mountimg">Montar imagem</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#burniso">Queimar ISO</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#createimg">Criar imagem</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#creatememdisk">Disco de memória</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#diskperf">Desempenho de disco</a></p>
<h2 id="permissions">Permissões</h2>
Altere permissão e proprietário com o <code>chmod</code> e <code>chown</code>. O umask padrão pode ser alterado para todos os usuários em /etc/profile para Linux ou /etc/login.conf para FreeBSD. O umask padrão é normalmente 022. O umask é subtraído a partir do  777, assim o umask 022 resulta em uma permissão de 755.
<pre>1 --x execute                        <span class="cmt"># Mode 764 = exec/read/write | read/write | read</span>
2 -w- write                          <span class="cmt"># For:       |--  Owner  --|   |- Group-|   |Oth|</span>
4 r-- read
  ugo=a                              <span class="cmt">u=user, g=group, o=others, a=everyone</span>
</pre>
<pre># chmod [OPTION] MODE[,MODE] FILE    <span class="cmt"># MODE é da forma [ugoa]*([-+=]([rwxXst]))</span>
# chmod 640 /var/log/maillog         <span class="cmt"># Restrito ao log -rw-r-----</span>
# chmod u=rw,g=r,o= /var/log/maillog <span class="cmt"># O mesmo que acima</span>
# chmod -R o-r /home/*               <span class="cmt"># Remove recursivamente outros legíveis para todos os usuários</span>
# chmod u+s /path/to/prog            <span class="cmt"># Configura o SUID bit no executável (Saiba o que fazer!)</span>
# find / -perm -u+s -print           <span class="cmt"># Encontra todos os progra,as com o SUID bit</span>
# chown user:group /path/to/file     <span class="cmt"># Altera o usuário e proprietário do grupo de um arquivo</span>
# chgrp group /path/to/file          <span class="cmt"># Altera o proprietário de um grupo de um arquivo</span>
# chmod 640 `find ./ -type f -print` <span class="cmt"># Altera as permissões para 640 para todos os arquivos</span>
# chmod 751 `find ./ -type d -print` <span class="cmt"># Altera as permissões paa 751 para todos os diretórios</span>
</pre>
<h2 id="diskinfo">Informações de disco</h2>
<pre># diskinfo -v /dev/ad2               <span class="cmt"># informaçõe a respeito do disco (sector/size) FreeBSD</span>
# hdparm -I /dev/sda                 <span class="cmt"># informação a respeito do disco IDE/ATA (Linux)</span>
# fdisk /dev/ad2                     <span class="cmt"># Exibe e manipula a tabela de partição</span>
# smartctl -a /dev/ad2               <span class="cmt"># Exibe a informação disk SMART</span>
</pre>
<h2 id="fsboot">Boot</h2>
<h3>FreeBSD</h3>
Para iniciar (boot) um kernel antigo se o novo não iniciar, pare o boot durante a contagem regressiva.
<pre># unload
# load kernel.old
# boot
</pre>

<h2 id="mountpoints">Pontos de montagem do sitema/Uso de disco</h2>
<pre># mount | column -t                  <span class="cmt"># Mostra o sistemas de arquivos montados no sistema</span>
# df                                 <span class="cmt"># Exibe espaço livre de disco e dispositivos montados</span>
# cat /proc/partitions               <span class="cmt"># Mostra todas as partições registradas (Linux)</span>
</pre>

<h3 id="diskusage">Uso de disco</h3>
<pre># du -sh *                           <span class="cmt"># Tamanhos de diretórios como listado</span>
# du -csh                            <span class="cmt"># Tamanaho total do diretório atual</span>
# du -ks * | sort -n -r              <span class="cmt"># Classifica tudo por tamanho em kilobytes</span>
# ls -lSr                            <span class="cmt"># Mostra arquivos, maiores por ultimo</span>
</pre>

<h2 id="filesstat">Quem tem quais arquivos abertos</h2>
Isso é util para descobrir qual arquivo está bloqueando uma partição que tem que ser desmontada e dá um típico erro de:
<pre># umount /home/
umount: unmount of /home             <span class="cmt"># umount impossible because a file is locking home (impossível desmontar por que um arquivo está travando o home)</span>
   failed: Device busy (falhou: dispositivo ocupado)
</pre>
<h3>FreeBSD e muitos Unixes</h3>
<pre># fstat -f /home                     <span class="cmt"># para um ponto de montagem</span>
# fstat -p PID                       <span class="cmt"># para uma aplicação com o PID</span>
# fstat -u user                      <span class="cmt"># para um name</span>
</pre>

Encontre arquivo de log aberto (ou outros arquivos abertos), diga para o Xorg:
<pre># ps ax | grep Xorg | awk '{print $1}'
1252
# fstat -p 1252
USER     CMD          PID   FD MOUNT      INUM MODE         SZ|DV R/W
root     Xorg        1252 root /             2 drwxr-xr-x     512  r
root     Xorg        1252 text /usr     216016 -rws--x--x  1679848 r
root     Xorg        1252    0 /var     212042 -rw-r--r--   56987  w
</pre>
O arquivo com o inum 212042 é o único arquivo em /var:
<pre># find -x /var -inum 212042
/var/log/Xorg.0.log
</pre>

<h3>Linux</h3>
Encontre arquivos abertos em um ponto de montagem com <code>fuser</code> ou <code>lsof</code>:
<pre># fuser -m /home                     <span class="cmt"># Lista processos accessando /home</span>
# lsof /home
COMMAND   PID    USER   FD   TYPE DEVICE    SIZE     NODE NAME
tcsh    29029 eedcoba  cwd    DIR   0,18   12288  1048587 /home/eedcoba (guam:/home)
lsof    29140 eedcoba  cwd    DIR   0,18   12288  1048587 /home/eedcoba (guam:/home)
</pre>
Sobre uma aplicação:
<pre>ps ax | grep Xorg | awk '{print $1}'
3324
# lsof -p 3324
COMMAND   PID    USER   FD   TYPE DEVICE    SIZE    NODE NAME
Xorg    3324 root    0w   REG        8,6   56296      12492 /var/log/Xorg.0.log
</pre>

Sobre um único arquivo:
<pre># lsof /var/log/Xorg.0.log
COMMAND  PID USER   FD   TYPE DEVICE  SIZE  NODE NAME
Xorg    3324 root    0w   REG    8,6 56296 12492 /var/log/Xorg.0.log
</pre>

<h2 id="mountcd">Monta/remonta um sistema de arquivo</h2>
Por exemplo o cdrom. Se listado em /etc/fstab:
<pre># mount /cdrom</pre>
Ou encontre o dispositivo em /dev/ ou com o dmesg
<h3>FreeBSD</h3>
<pre># mount -v -t cd9660 /dev/cd0c /mnt  <span class="cmt"># cdrom</span>
# mount_cd9660 /dev/wcd0c /cdrom     <span class="cmt"># outro método</span>
# mount -v -t msdos /dev/fd0c /mnt   <span class="cmt"># floppy</span>
</pre>
Entrada em /etc/fstab:
<pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/acd0               /cdrom          cd9660  ro,noauto       0       0
</pre>
Para deixar os usuários fazerem isso:
<pre># sysctl vfs.usermount=1  <span class="cmt"># Ou insira a linha "vfs.usermount=1" in /etc/sysctl.conf</span>
</pre>

<h3>Linux</h3>
<pre># mount -t auto /dev/cdrom /mnt/cdrom   <span class="cmt"># comando mount típico do para cdrom</span>
# mount /dev/hdc -t iso9660 -r /cdrom   <span class="cmt"># IDE típico</span>
# mount /dev/scd0 -t iso9660 -r /cdrom  <span class="cmt"># cdrom SCSI típico</span>
# mount /dev/sdc0 -t ntfs-3g /windows   <span class="cmt"># SCSI típico</span>
</pre>
Entrada em /etc/fstab:
<pre>/dev/cdrom   /media/cdrom  subfs noauto,fs=cdfss,ro,procuid,nosuid,nodev,exec 0 0</pre>
<h4>Montar uma partição FreeBSD com o Linux</h4>
Encontre o número da partição continda com o fdisk, essa é normalmente a partição root,mas pode ser uma outra outra fatia de BSD também. Se o FreeBSD tiver muitas fatias, elas são as não listadas na tabela do fdisk, mas visíveis em /dev/sda* ou /dev/hda*.
<pre># fdisk /dev/sda                     <span class="cmt"># Encontre a partição FreeBSD</span>
/dev/sda3   *        5357        7905    20474842+  a5  FreeBSD
# mount -t ufs -o ufstype=ufs2,ro /dev/sda3 /mnt
/dev/sda10 = /tmp; /dev/sda11 /usr   <span class="cmt"># As outras fatias</span>
</pre>
<h3 id="remount">Remontar</h3>
Remontar um dispositivo sem remontá-lo. Necessário para o fsck
<pre># mount -o remount,ro /              <span class="cmt"># Linux</span>
# mount -o ro -u /                   <span class="cmt"># FreeBSD</span>
</pre>
Copiar o arquivo  bruto a partir de um cdrom dentro de uma imagem iso (tamanho de blocos padrão de 512  podem causar problemas):
<pre># dd if=/dev/cd0c of=file.iso bs=2048</pre>
<h3 id="virtualbox">Virtualbox</h3>
Permite um compartilhamento no host:
<pre># VBoxManage sharedfolder add "GuestName" --name "share" --hostpath "C:\hostshare"</pre>
Montar compartilhamento no guest (convidado) (linux, FreeBSD)
<pre># sudo mount -t vboxsf share /home/vboxshare <span class="cmt"># -o uid=1000,gid=1000 (as appropriate)</span>
share /home/colin/share vboxsf defaults,uid=colin 0 0 <span class="cmt"># fstab entry</span>
</pre>
<h3 id="osxdisk">OSX</h3>
<pre># diskutil list                      <span class="cmt"># Lista as partições de um disco</span>
# diskutil unmountDisk /dev/disk1    <span class="cmt"># Desmonta um disco inteiro (todos os volumes)</span>
# chflags hidden ~/Documents/folder  <span class="cmt"># Enconde pastas (diretórios) (reverta com o unhidden)</span>
</pre>
<h2 id="addswap">Adicionar swap com o sistema em pleno uso (on-the-fly)</h2>
Suponhamos que você precise de mais swap (agora mesmo), diga um arquivo de 2GB /swap2gb (somente em Linux).
<pre># dd if=/dev/zero of=/swap2gb bs=1024k count=2000
# mkswap /swap2gb                    <span class="cmt"># cria a área de swap</span>
# swapon /swap2gb                    <span class="cmt"># ativa a swap. Isso agora em uso</span>
# swapoff /swap2gb                   <span class="cmt"># Quando feito desative a swap</span>
# rm /swap2gb
</pre>

<h2 id="mountsmb">Montar um compartilhamento SMB</h2>
Suponhamos que queremos acessar compartilhamento SMB myshare no computador smbserver, o endereço como digitado em um PC Windows PC é \\smbserver\myshare\. Nós montamos no /mnt/smbshare. Warning&gt; cifs wants an IP or DNS name, not a Windows name.
<h3>Linux/OSX</h3>
<pre># smbclient -U user -I 192.168.16.229 -L //smbshare/    <span class="cmt"># Lista os compartilhamentos</span>
# mount -t smbfs -o username=winuser //smbserver/myshare /mnt/smbshare
# mount -t cifs -o username=winuser,password=winpwd //192.168.16.229/myshare /mnt/share
</pre>
Montar o compartilhamento Samba através de um túnel sshl
<pre># ssh -C -f -N -p 20022 -L 445:127.0.0.1:445 me@server  <span class="cmt"># connect on 20022, tunnel 445</span>
# mount -t smbfs //colin@localhost/colin ~/mnt
# mount_smbfs //colin:mypassword@127.0.0.1/private /Volumes/private <span class="cmt"># I use this on OSX + ssh</span>
</pre>
Adicionalmente com o pacote mount.cifs é possível armazenar as credentiais em um arquivo, por exemplo <code>/home/user/.smb</code>:
<pre>username=winuser
password=winpwd
</pre>
E monte como a seguir:
<pre># mount -t cifs -o credentials=/home/user/.smb //192.168.16.229/myshare /mnt/smbshare</pre>

<h3>FreeBSD</h3>
Utilize -I para dar o IP (ou DNS name); smbserver é o nome Windows.
<pre># smbutil view -I 192.168.16.229 //winuser@smbserver    <span class="cmt"># Liste os compartilhamentos</span>
# mount_smbfs -I 192.168.16.229 //winuser@smbserver/myshare /mnt/smbshare
</pre>

<h2 id="mountimg">Montar umma imagem</h2>
<pre># hdiutil mount image.iso                               <span class="cmt"># OS X</span></pre>
<h3>Linux loop-back</h3>
<pre># mount -t iso9660 -o loop file.iso /mnt                <span class="cmt"># Monte uma imagem de CD</span>
# mount -t ext3 -o loop file.img /mnt                   <span class="cmt"># Monte uma umagem com o sistema de arquivos ext3</span>
</pre>

<h3>FreeBSD</h3>
Com dispositivo de moméria (faça # kldload md.ko se necessário):
<pre># mdconfig -a -t vnode -f file.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
# umount /mnt; mdconfig -d -u 0                         <span class="cmt"># Limpa o dispositivo md</span>
</pre>
Ou como node virtual:
<pre># vnconfig /dev/vn0c file.iso; mount -t cd9660 /dev/vn0c /mnt
# umount /mnt; vnconfig -u /dev/vn0c                    <span class="cmt"># Limpa o dispositivo vn</span>
</pre>

<h3>Solaris e FreeBSD</h3>
Com interface de arquivo loop-back ou lofi:
<pre># lofiadm -a file.iso
# mount -F hsfs -o ro /dev/lofi/1 /mnt
# umount /mnt; lofiadm -d /dev/lofi/1                   <span class="cmt"># Limpa o dispositivo lofi</span>
</pre>
<h2 id="burniso">Criar e queimar uma imagem ISO</h2>
Isso copiar o cd ou DVD setor por setor. Sem <code>conv=notrunc</code>, a imagem será pequena se há menos conteúdo no cd. Veja abaixo os <a class="xref" href="http://cb.vu/unixtoolbox.xhtml#dd">exemplos dd</a>.
<pre># dd if=/dev/hdc of=/tmp/mycd.iso bs=2048 conv=notrunc</pre>
Utilize mkisofs para criar uma imagem de CD/DVD image a partir de um diretório. Para superar as restrições de nomes de arquivos: -r abilit as extenções comuns Rock Ridge para sistemas UNIX, -J abilita extenções  Joliet utilizada pelos sistemas Microsoft. -L permite nomes de arquivos ISO9660 iniciar com um período.
<pre># mkisofs -J -L -r -V TITLE -o imagefile.iso /path/to/dir
# hdiutil makehybrid -iso -joliet -o dir.iso dir/       <span class="cmt"># OS X</span></pre>
No FreeBSD, mkisofs é encontrato no ports em sysutils/cdrtools.
<h3>Queimar uma imagem de CD/DVD ISO</h3>
<h4>FreeBSD</h4>
FreeBSD não abilita a DMA nos drivers ATAPI por padrão. A DMA é abilitada com o comando sysctl e os argumentos abaixo, ou com /boot/loader.conf com as seguintes entradas:
<pre>hw.ata.ata_dma="1"
hw.ata.atapi_dma="1"
</pre>
Utilize <code>burncd</code> com um dispositivo ATAPI (<code>burncd</code> é parte do base system) e <code>cdrecord</code> (em sysutils/cdrtools) com um drive SCSI.
<pre># burncd -f /dev/acd0 data imagefile.iso fixate      <span class="cmt">#Para drive ATAPI</span>
# cdrecord -scanbus                  <span class="cmt"># Para encontrar o dispositivo gravador (como 1,0,0)</span>
# cdrecord dev=1,0,0 imagefile.iso
</pre>
<h4>Linux</h4>
Também utiliza <code>cdrecord</code> com Linux como descrito acima. Adicionalmente é possível utilizar a interface ATAPI nativa que é encontrada com:
<pre># cdrecord dev=ATAPI -scanbus</pre>
e queime o CD/DVD como acima.
<h4>dvd+rw-tools</h4>
O pacote <a href="http://fy.chalmers.se/~appro/linux/DVD+RW/">dvd+rw-tools</a> (FreeBSD: ports/sysutils/dvd+rw-tools) pode fazer tudo isso e inclui <code>growisofs</code> para queimar CDs ou DVDs. Os exemplos referem-se ao dispositivo de dvd como <code>/dev/dvd</code> que podia ser um symlink para <code>/dev/scd0</code> (scsi típico no Linux) ou <code>/dev/cd0</code> (FreeBSD típico) ou <code>/dev/rcd0c</code> (SCSI de caracter típico do NetBSD/OpenBSD) ou <code>/dev/rdsk/c0t1d0s2</code> (exemplo de uma dispositivo de caracter CD-ROM SCSI/ATAPI do Solaris). Há uma documentação boa com exemplos no <a href="http://www.freebsd.org/handbook/creating-dvds.html">FreeBSD handbook capítulo 18.7</a><span class="fn">http://www.freebsd.org/handbook/creating-dvds.html</span>.
<pre>                       <span class="cmt"># -dvd-compat closes the disk</span>
# growisofs -dvd-compat -Z /dev/dvd=imagefile.iso     <span class="cmt"># Queima imagem iso existente</span>
# growisofs -dvd-compat -Z /dev/dvd -J -R /p/to/data  <span class="cmt"># Queima diretamente</span>
</pre>

<h3>Converter um arquivo Nero .nrg  para .iso</h3>
O Nero simplesmente adicionas um cabeçalho de 300Kb em uma imagem iso normal. Isso pode ser aparado com o dd.
<pre># dd bs=1k if=imagefile.nrg of=imagefile.iso skip=300</pre>
<h3>Converter uma imagem bin/cue para .iso</h3>
O título <a href="http://freshmeat.net/projects/bchunk/"><code>bchunk</code> program</a><span class="fn">http://freshmeat.net/projects/bchunk/</span> pode fazer isso. Ele está no ports do FreeBSD em sysutils/bchunk.
<pre># bchunk imagefile.bin imagefile.cue imagefile.iso
</pre>

<h2 id="createimg">Criar uma imagem basada em arquivo</h2>
Por exemplo uma partição de 1GB utilizando o arquivo /usr/vdisk.img. Aqui no utilizamos o vnode 0, mas podia ser também 1.
<h3>FreeBSD</h3>
<pre># dd if=/dev/random of=/usr/vdisk.img bs=1K count=1M
# mdconfig -a -t vnode -f /usr/vdisk.img -u 0         <span class="cmt"># Cria o dispositivo /dev/md1</span>
# bsdlabel -w /dev/md0
# newfs /dev/md0c
# mount /dev/md0c /mnt
# umount /mnt; mdconfig -d -u 0; rm /usr/vdisk.img    <span class="cmt"># Limpa o dispositivo md</span>
</pre>
A imagem baseada em arquivo pode ser automaticalmente montada durante o boot com uma entrada em /etc/rc.conf e /etc/fstab. Teste sua configuração com o <code># /etc/rc.d/mdconfig start</code> (primeiro exclua o dispositivo md0 com o  <code># mdconfig -d -u 0</code>).<br />
Note no entando que essa configuração automatica só funcionará se a imagem de arquivo não estiver na partição root. A rasão é o script /etc/rc.d/mdconfig é executado durante o boot e a partição root ainda está em somente leitura (read-only). Imagens localizadas fora da partição root serão montadas mounted mais tarde com o script /etc/rc.d/mdconfig2.<br />
/boot/loader.conf:
<pre>md_load="YES"</pre>
/etc/rc.conf:
<pre># mdconfig_md0="-t vnode -f /usr/vdisk.img"          <span class="cmt"># /usr não está na partição root</span></pre>
/etc/fstab: (O 0 0 no final é importante, Isso diz ao fsck que ignore esse dispositivo, como ainda não exite)
<pre>/dev/md0                /usr/vdisk      ufs     rw              0       0</pre>
Também é possível almentar o tamanho da imagem  depois, digamos por exemplo 300 MB maior.
<pre># umount /mnt; mdconfig -d -u 0
# dd if=/dev/zero bs=1m count=300 &gt;&gt; /usr/vdisk.img
# mdconfig -a -t vnode -f /usr/vdisk.img -u 0
# growfs /dev/md0
# mount /dev/md0c /mnt                                <span class="cmt"># Partição do arqiuvo é agora 300 MB maior</span>
</pre>

<h3>Linux</h3>

<pre># dd if=/dev/zero of=/usr/vdisk.img bs=1024k count=1024
# mkfs.ext3 /usr/vdisk.img
# mount -o loop /usr/vdisk.img /mnt
# umount /mnt; rm /usr/vdisk.img                      <span class="cmt"># Limpa</span>
</pre>
<h3 id="losetup">Linux com o losetup</h3>
<code>/dev/zero</code> é muito mais rapido do que o <code>urandom</code>, mas menos seguro para criptografia.
<pre># dd if=/dev/urandom of=/usr/vdisk.img bs=1024k count=1024
# losetup /dev/loop0 /usr/vdisk.img                   <span class="cmt"># Cria e associa /dev/loop0</span>
# mkfs.ext3 /dev/loop0
# mount /dev/loop0 /mnt
# losetup -a                                          <span class="cmt"># Verificar loops utilizados</span>
# umount /mnt
# losetup -d /dev/loop0                               <span class="cmt"># Destaca</span>
# rm /usr/vdisk.img
</pre>

<h2 id="creatememdisk">Criar um sistema de arquivo de memória</h2>
Um sistema de arquivo baseado em memória é muito rápido para aplicações de entrada e saída (IO). Como criar uma partição de 64 MB montada em /memdisk:
<h3>FreeBSD</h3>
<pre># mount_mfs -o rw -s 64M md /memdisk
# umount /memdisk; mdconfig -d -u 0                   <span class="cmt"># Limpa o dispositivo md</span>
md     /memdisk     mfs     rw,-s64M    0   0         <span class="cmt"># /etc/fstab entrada</span>
</pre>
<h3>Linux</h3>
<pre># mount -t tmpfs -osize=64m tmpfs /memdisk
</pre>

<h2 id="diskperf">Desempenho de disco</h2>
Lê e escreve um arquivo de 1 GB na partição (/home)
<pre># time dd if=/dev/ad4s3c of=/dev/null bs=1024k count=1000
# time dd if=/dev/zero bs=1024k count=1000 of=/home/1Gb.file
# hdparm -tT /dev/hda      <span class="cmt"># Somente em Linux</span>
</pre>
</div>

<div id="network"><h1><a>Rede</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#routing">Rotear</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#secondip">IP adicional</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#changemac">Alterar MAC</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#ports">Portas</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#firewall">Firewall</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#ipforward">IP Forward</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#nat">NAT</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#dns">DNS</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#dhcp">DHCP</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#traffic">Traffic</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#trafficctrl">QoS</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#nis">NIS</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#netcat">Netcat</a></p>
<h2 id="netdebug">Debugging (Veja também <a class="xref" href="http://cb.vu/unixtoolbox.xhtml#traffic">Análise de tráfego)</a></h2>
<h3>Linux</h3>
<pre># ethtool eth0              <span class="cmt"># Exibe o status da  ethernet (subsitui mii-diag)</span>
# ethtool -s eth0 speed 100 duplex full <span class="cmt"># Força o Full duplex de 100Mbit</span>
# ethtool -s eth0 autoneg off <span class="cmt"># Disabilita negociação automática ( auto negotiation)</span>
# ethtool -p eth1           <span class="cmt"># Pisca o led de ethernet - muito util quando suportado</span>
# ip link show              <span class="cmt"># Exibe todas as interfaces no Linux (similar ao ifconfig)</span>
# ip link set eth0 up       <span class="cmt"># Traz o dispositivo ao funcionamento (ou derruba-o). O mesmo que "ifconfig eth0 up"</span>
# ip addr show              <span class="cmt"># Exibe todos os endereços de IP no Linux (similar ao ifconfig)</span>
# ip neigh show             <span class="cmt"># Similar ao arp -a</span>
</pre>
<h3>Outros OSes</h3>
<pre># ifconfig fxp0             <span class="cmt"># Verifica o campo "media" no FreeBSD</span>
# arp -a                    <span class="cmt"># Verifica a entrada ARP do roteador (ou host) (todos os OS)</span>
# ping cb.vu                <span class="cmt"># A primeira coisa a testar...</span>
# traceroute cb.vu          <span class="cmt"># Imprime o caminho do roteador para o destino</span>
# ifconfig fxp0 media 100baseTX mediaopt full-duplex <span class="cmt"># 100Mbit full duplex (FreeBSD)</span>
# netstat -s                <span class="cmt"># Estatisticas do System-wide para cada protocolo de rede</span>
</pre>
Comandos adicionais que não são sempre instaladospor padrão, mas faceis de encontrar:
<pre># arping 192.168.16.254     <span class="cmt"># Ping na camada ethernet</span>
# tcptraceroute -f 5 cb.vu  <span class="cmt"># utiliza o tcp ao inves do icmp para traçar pelos firewalls</span>
</pre>

<h2 id="routing">Rotear</h2>
<h3>Imprimir tabela de roteamento</h3>
<pre># route -n                  <span class="cmt"># Linux ou utilize o "ip route"</span>
# netstat -rn               <span class="cmt"># Linux, BSD e UNIX</span>
# route print               <span class="cmt"># Windows</span>
</pre>
<h3 id="addroute">Adicionar e excluir uma rota</h3>
<h4>FreeBSD</h4>
<pre># route add 212.117.0.0/16 192.168.1.1
# route delete 212.117.0.0/16
# route add default 192.168.1.1
</pre>
Adiciona rota permanentemente em in /etc/rc.conf
<pre>static_routes="myroute"
route_myroute="-net 212.117.0.0/16 192.168.1.1"
</pre>
<h4>Linux</h4>
<pre># route add -net 192.168.20.0 netmask 255.255.255.0 gw 192.168.16.254
# ip route add 192.168.20.0/24 via 192.168.16.254       <span class="cmt"># o mesmo que acima com o ip route</span>
# route add -net 192.168.20.0 netmask 255.255.255.0 dev eth0
# route add default gw 192.168.51.254
# ip route add default via 192.168.51.254 dev eth0      <span class="cmt"># o mesmo que acima com o ip route</span>
# route delete -net 192.168.20.0 netmask 255.255.255.0
</pre>
<h4>Solaris</h4>
<pre># route add -net 192.168.20.0 -netmask 255.255.255.0 192.168.16.254
# route add default 192.168.51.254 1                    <span class="cmt"># 1 = salta para o próximo gateway</span>
# route change default 192.168.50.254 1
</pre>
Entradas permanentes são configuradas na entrada em <code>/etc/defaultrouter</code>.
<h4>Windows</h4>
<pre># Route add 192.168.50.0 mask 255.255.255.0 192.168.51.253
# Route add 0.0.0.0 mask 0.0.0.0 192.168.51.254</pre>
Utilize add -p para tornar a rota persistente.

<h2 id="secondip">Configurar endereços de IP adicionais</h2>
<h3>Linux</h3>
<pre># ifconfig eth0 192.168.50.254 netmask 255.255.255.0       <span class="cmt"># Primeiro IP</span>
# ifconfig eth0:0 192.168.51.254 netmask 255.255.255.0     <span class="cmt"># Segundo IP</span>
# ip addr add 192.168.50.254/24 dev eth0                   <span class="cmt"># Comandos de ip equivalentes</span>
# ip addr add 192.168.51.254/24 dev eth0 label eth0:1
</pre>
<h3>FreeBSD</h3>
<pre># ifconfig fxp0 inet 192.168.50.254/24                     <span class="cmt"># Priemiro IP</span>
# ifconfig fxp0 alias 192.168.51.254 netmask 255.255.255.0 <span class="cmt"># Segundo IP</span>
# ifconfig fxp0 -alias 192.168.51.254                      <span class="cmt"># Remove o apelido do segundo IP</span>
</pre>Entradas permanentes em /etc/rc.conf                   
<pre>ifconfig_fxp0="inet 192.168.50.254  netmask 255.255.255.0"
ifconfig_fxp0_alias0="192.168.51.254 netmask 255.255.255.0"
</pre>
<h3>Solaris</h3>
Verifica as configurações com o <code>ifconfig -a</code>
<pre># ifconfig hme0 plumb                                      <span class="cmt"># Abilita a placa de rede</span>
# ifconfig hme0 192.168.50.254 netmask 255.255.255.0 up    <span class="cmt"># Primeiro IP</span>
# ifconfig hme0:1 192.168.51.254 netmask 255.255.255.0 up  <span class="cmt"># Segundo IP</span>
</pre>

<h2 id="changemac">Altera o MAC address</h2>
Normalmente tem se que derrubar a interface antes da alteração. Não me diga o por que você quer deseja alterar o endereço de máquina (MAC address)...
<pre># ifconfig eth0 down
# ifconfig eth0 hw ether 00:01:02:03:04:05      <span class="cmt"># Linux</span>
# ifconfig fxp0 link 00:01:02:03:04:05          <span class="cmt"># FreeBSD</span>
# ifconfig hme0 ether 00:01:02:03:04:05         <span class="cmt"># Solaris</span>
# sudo ifconfig en0 ether 00:01:02:03:04:05     <span class="cmt"># OS X Tiger, Snow Leopard LAN*</span>
# sudo ifconfig en0 lladdr 00:01:02:03:04:05    <span class="cmt"># OS X Leopard</span>
</pre>
*Interface de rede sem fio típica é <code>en1</code> e precisa disassociar do qualquer rede primeiro (<a href="http://osxdaily.com/2008/01/17/how-to-spoof-your-mac-address-in-mac-os-x/">osxdaily howto</a>).
<pre># echo "alias airport='/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport'"\
&gt;&gt; ~/.bash_profile         <span class="cmt"># ou symlink para /usr/sbin</span>
# airport -z               <span class="cmt"># Disassocia das redes sem fio</span>
# airport -I               <span class="cmt"># Obter informação da rede sem fio</span></pre>
Muitas ferramentas existem para Windows. Por exemplo <a href="http://ntsecurity.nu/toolbox/etherchange/">etherchange</a><span class="fn">http://ntsecurity.nu/toolbox/etherchange</span>. Ou procure por "Mac Makeup", "smac".

<h2 id="ports">Portas em uso</h2>
Escutar portas abertas:
<pre># netstat -an | grep LISTEN
# lsof -i                  <span class="cmt"># Lista todas as conexões com a internet no Linux</span>
# socklist                 <span class="cmt"># Exibe lista de sockets abertos no Linux</span>
# sockstat -4              <span class="cmt"># Lista aplicações no FreeBSD</span>
# netstat -anp --udp --tcp | grep LISTEN        <span class="cmt"># Linux</span>
# netstat -tup             <span class="cmt"># Lista conexões activas para/a partir do sistema (Linux)</span>
# netstat -tupl            <span class="cmt"># Lista portas que estão sendo escutadas a artir do sistema (Linux)</span>
# netstat -ano             <span class="cmt"># Windows</span>
</pre>

<h2 id="firewall">Firewall</h2>
Verificar se um firewall está rodando (somenete a configuração típica):
<h3>Linux</h3>
<pre># iptables -L -n -v                  <span class="cmt"># Para status</span>
Open the iptables firewall
# iptables -P INPUT       ACCEPT     <span class="cmt"># Abre tudo</span>
# iptables -P FORWARD     ACCEPT
# iptables -P OUTPUT      ACCEPT
# iptables -Z                        <span class="cmt"># Zera o pacote e os contadores de byte em todas as conrrentes</span>
# iptables -F                        <span class="cmt"># Nivelar todas as correntes</span>
# iptables -X                        <span class="cmt"># Exclui todas as correntes</span>
</pre>
<h3>FreeBSD</h3>
<pre># ipfw show                          <span class="cmt"># para status</span>
# ipfw list 65535 <span class="cmt"># se a resposta for "65535 deny ip from any to any" o fw está desabilitado</span>
# sysctl net.inet.ip.fw.enable=0     <span class="cmt"># Desabilita</span>
# sysctl net.inet.ip.fw.enable=1     <span class="cmt"># abilita</span>
</pre>
<h2 id="ipforward">Direcionamento de IP para roteamento</h2>
<h3>Linux</h3>
Verificar e então abilitar o direcionamento de IP com:
<pre># cat /proc/sys/net/ipv4/ip_forward  <span class="cmt"># Verifica o direcionamento de IP 0=off, 1=on</span>
# echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</pre>
ou editar /etc/sysctl.conf com:
<pre>net.ipv4.ip_forward = 1</pre>

<h3>FreeBSD</h3>
Verifique e abilite com:
<pre># sysctl net.inet.ip.forwarding      <span class="cmt"># Verifica o direcionamento de IP 0=off, 1=on</span>
# sysctl net.inet.ip.forwarding=1
# sysctl net.inet.ip.fastforwarding=1	<span class="cmt"># Para roteador ou firewall dedicado</span>
Permanent with entry in /etc/rc.conf:
gateway_enable="YES"                 <span class="cmt"># Define para YES se esse host vai ser um gateway.</span>
</pre>

<h3>Solaris</h3>
<pre># ndd -set /dev/ip ip_forwarding 1   <span class="cmt"># Define o direcionamento do IP 0=off, 1=on</span>
</pre>

<h2 id="nat">NAT Network Address Translation (Tradução de Endereço de Rede)</h2>
<h3>Linux</h3>
<pre># iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE	<span class="cmt"># para ativar o NAT</span>
# iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 --dport 20022 -j DNAT \
--to 192.168.16.44:22           <span class="cmt"># Direcionameto de porta 20022 para porta ssh de IP interno</span>
# iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 --dport 993:995 -j DNAT \
--to 192.168.16.254:993-995     <span class="cmt"># Direcionamento de porta com alcance (range) entre 993-995</span>
# ip route flush cache
# iptables -L -t nat            <span class="cmt"># Verifica status do NAT</span>
</pre>
Exclui o direcionamento de porta com o -D ao inves do -A. O programa <a href="http://tweegy.nl/projects/netstat-nat/">netstat-nat</a><span class="fn">http://tweegy.nl/projects/netstat-nat</span> é muito útil para rastrear conexões (ele utiliza <code>/proc/net/ip_conntrack</code> ou <code>/proc/net/nf_conntrack</code>).
<pre># netstat-nat -n                <span class="cmt"># Exibe todas as conexões com IPs</span></pre>

<h3>FreeBSD</h3>
<pre># natd -s -m -u -dynamic -f /etc/natd.conf -n fxp0
Or edit /etc/rc.conf with:
firewall_enable="YES"           <span class="cmt"># Define para YES para abilitar a funcionalidade do firewall</span>
firewall_type="open"            <span class="cmt"># Tipo de Firewall (veja /etc/rc.firewall)</span>
natd_enable="YES"               <span class="cmt"># Abilita natd (se firewall_enable == YES).</span>
natd_interface="tun0"           <span class="cmt"># Iterface pública ou endereço de IP para utilizar.</span>
natd_flags="-s -m -u -dynamic -f /etc/natd.conf"
</pre>
Port forward with:
<pre># cat /etc/natd.conf 
same_ports yes
use_sockets yes
unregistered_only
# redirect_port tcp insideIP:2300-2399 3300-3399  <span class="cmt"># rangde de porta</span>
redirect_port udp 192.168.51.103:7777 7777
</pre>

<h2 id="dns">DNS</h2>
Em Unix as entradas de DNS são válidas para todas as interfaces e são armazenadas em /etc/resolv.conf. O domínio para a qual o host pertence também está armazenado nesse arquivo. Uma configuração mínima é:
<pre>nameserver 78.31.70.238
search sleepyowl.net intern.lab
domain sleepyowl.net
</pre>
Verificar o nome do domíniop com:
<pre># hostname -d                        <span class="cmt"># O mesmo que dnsdomainname</span></pre>
<h3>Windows</h3>
No Windows os DNS estão configurados por interface. Para exibir os DNS configurados e para limpar (flush) o cache de DNS utilize:
<pre># ipconfig /?                        <span class="cmt"># Exibir ajuda</span>
# ipconfig /all                      <span class="cmt"># Veja todas as informações incluindo DNS</span>
</pre>
<h3>Flush DNS</h3>
Limpar (flush) o cache de DNS do sistema operacional, algumas aplicações utilizando seu próprio cache (ex. Firefox) e não serão afetados.
<pre># /etc/init.d/nscd restart           <span class="cmt"># Reiniciar nscd se utilizado - Linux/BSD/Solaris</span>
# lookupd -flushcache                <span class="cmt"># OS X Tiger</span>
# dscacheutil -flushcache            <span class="cmt"># OS X Leopard e mais recentes</span>
# ipconfig /flushdns                 <span class="cmt"># Windows</span>
</pre>
<h3>Consulta de direcionameto</h3>
Dig é seu amigo nos testest de configurações de DNS. Por exemplo o servidor de DNS público <code>213.133.105.2 ns.second-ns.de</code> pode ser utilizado para teste. Veja de qual servidor o cliente recebe a resposta (resposta simplificada).
<pre># dig sleepyowl.net
sleepyowl.net.          600     IN      A       78.31.70.238
;; SERVER: 192.168.51.254#53(192.168.51.254)
</pre>
O roteadr 192.168.51.254 respondeu e a resposta é a entrada A. Qualquer entrada pode ser consultada e o servidor DNS pode ser selecionado com @:
<pre># dig MX google.com
# dig @127.0.0.1 NS sun.com          <span class="cmt"># Para testar o servidor local</span>
# dig @204.97.212.10 NS MX heise.de  <span class="cmt"># Consulta um servidor externo</span>
# dig AXFR @ns1.xname.org cb.vu      <span class="cmt"># Obtem a zona completa (zone transfer)</span>
</pre>
O programa host também é poderoso.
<pre># host -t MX cb.vu                   <span class="cmt"># obtem a entrada do mail MX</span>
# host -t NS -T sun.com              <span class="cmt"># Obtem registro de NS sobre uma conexão TCP</span>
# host -a sleepyowl.net              <span class="cmt"># Obter tudo</span>
</pre>

<h3>Reverter consultas</h3>
Encontre um nome pertencente á um endereço de IP (in-addr.arpa.). Isso pode ser feito com <code>dig</code>, <code>host</code> e <code>nslookup</code>:
<pre># dig -x 78.31.70.238
# host 78.31.70.238
# nslookup 78.31.70.238
</pre>

<h3>/etc/hosts</h3>
Hosts únicos pode ser configurados no arquivo /etc/hosts ao inves de rodar <code>named</code> localmente para resolver as consultas de hostname. o formato ésimples, por exemplo:
<pre>78.31.70.238   sleepyowl.net   sleepyowl</pre>
A prioridade entre hosts e uma consulta de dns, que é a ordem de resolução de nome, pode ser configurada em <code>/etc/nsswitch.conf</code> AND /etc/host.conf. O arquvo também existe no Windows, normalmente está em:
<pre>C:\WINDOWS\SYSTEM32\DRIVERS\ETC</pre>

<h2 id="dhcp">DHCP</h2>
<h3>Linux</h3>
Algumas distribuições (SuSE) utilizam dhcpcd como cliente. a interface padrão é eth0.
<pre># dhcpcd -n eth0           <span class="cmt"># Renova (nem sempre funciona)</span>
# dhcpcd -k eth0           <span class="cmt"># libera e derruba</span>
</pre>
O lease com a informação completa está armazenada em:
<pre>/var/lib/dhcpcd/dhcpcd-eth0.info</pre>

<h3>FreeBSD</h3>
FreeBSD (e Debian) utiliza o dhclient. Para configurar uma interface (por exemplo bge0) rode:
<pre># dhclient bge0</pre>
O lease com a informação completa está armazenada em:
<pre>/var/db/dhclient.leases.bge0</pre>
Utilize <pre>/etc/dhclient.conf</pre> to preceder opções ou forçar opções diferentes:
<pre># cat /etc/dhclient.conf
interface "rl0" {
    prepend domain-name-servers 127.0.0.1;
    default domain-name "sleepyowl.net";
    supersede domain-name "sleepyowl.net";
}
</pre>

<h3>Windows</h3>
O dhcp lease pode ser renovado com <code>ipconfig</code>:
<pre># ipconfig /renew          <span class="cmt"># renova todos os adaptadores</span>
# ipconfig /renew LAN      <span class="cmt"># renova o adaptador nomeado "LAN"</span>
# ipconfig /release WLAN   <span class="cmt"># libera o adaptador nomeado "WLAN"</span>
</pre>
Sim é uma boa idea nomear seus adaptadores com nomes simples!


<h2 id="traffic">Análise de tráfego</h2>
<a href="http://people.suug.ch/~tgr/bmon/">Bmon</a><span class="fn">http://people.suug.ch/~tgr/bmon/</span> é um pequeno console monitor  de largura de banda e pode exibir o fluxo nas diferentes interfaces. 
<h3>Sniff com tcpdump</h3>
<pre># tcpdump -nl -i bge0 not port ssh and src \(192.168.16.121 or 192.168.16.54\)
# tcpdump -n -i eth1 net 192.168.16.121           <span class="cmt"># seleciona para/de um único IP</span>
# tcpdump -n -i eth1 net 192.168.16.0/24          <span class="cmt"># seleciona tráfego para/de uma rede</span>
# tcpdump -l &gt; dump &amp;&amp; tail -f dump               <span class="cmt"># Saída em Buffer</span>
# tcpdump -i rl0 -w traffic.rl0                   <span class="cmt"># Escreve cabeçalho tráfego em arquivo binário</span>
# tcpdump -i rl0 -s 0 -w traffic.rl0              <span class="cmt"># Escrever tráfego + payload em arquivo binário</span>
# tcpdump -r traffic.rl0                          <span class="cmt"># Lê a partir do arquivo (também para ethereal</span>
# tcpdump port 80                                 <span class="cmt"># Os dois comandos clássicos</span>
# tcpdump host google.com
# tcpdump -i eth0 -X port \(110 or 143\)          <span class="cmt"># Verifica se pop ou imap é seguro</span>
# tcpdump -n -i eth0 icmp                         <span class="cmt"># Somente captura pings</span>
# tcpdump -i eth0 -s 0 -A port 80 | grep GET      <span class="cmt"># -s 0 para total de pacotes -A para ASCII</span>
</pre>
Opções adicionais importação:
<ul style="list-style-type: none;">
  <li><code>-A</code>     Printa cada pacote em texto limpo (sem cabeçalho)</li>
  <li><code>-X</code>     Printa pacotes em hex e ASCII</li>
  <li><code>-l</code>     Faz linha de saída (stdout)em buffer</li>
  <li><code>-D</code>     Printa todas a interfaces disponíveis</li>
</ul>

No Windows usa windump a partir <a rel="nofollow" href="http://www.winpcap.org/">www.winpcap.org</a>. Use o windump -D para listar as interfaces.
<h3>Scan com nmap</h3>
<a rel="nofollow" href="http://insecure.org/nmap/">Nmap</a><span class="fn">http://insecure.org/nmap/</span> é scanner de portas com detecção do OS, é normalmente instalado em muitas distribuições e também está disponível para. Se você não scanear seu servidor, hackers (nota do tradutor: black hats no caso, e não white hats) fazem isso por você...
<pre># nmap cb.vu               <span class="cmt"># scanea todas as portas TCP reservadas no host</span>
# nmap -sP 192.168.16.0/24 <span class="cmt"># Descobre quais IP são utilizados e por qual host no 0/24</span>
# nmap -sS -sV -O cb.vu    <span class="cmt"># Faz um stealth SYN scan com versão e detecção de OS</span>
PORT      STATE  SERVICE             VERSION
22/tcp    open   ssh                 OpenSSH 3.8.1p1 FreeBSD-20060930 (protocol 2.0)
25/tcp    open   smtp                Sendmail smtpd 8.13.6/8.13.6
80/tcp    open   http                Apache httpd 2.0.59 ((FreeBSD) DAV/2 PHP/4.
[...]
Running: FreeBSD 5.X
Uptime 33.120 days (since Fri Aug 31 11:41:04 2007)
</pre>
Outras não padrões, mas ferramentas utei são <code>hping</code> (www.hping.org) um analizador/assembler (juntador) de pacotes IP e <code>fping</code> (fping.sourceforge.net). fping pode verificar múltiplos hosts em um estilo round-robin.

<h2 id="trafficctrl">Controle de Tráfego (QoS)</h2>
Controle de Tráfego gerencia a fila, policiamento, rotina, e outros parametros de tráfego para uma rede. Os exemplos a seguir são compatibilidades de usos práticos e simples do Linux e do FreeBSD para melhor uso da largura de banda disponível.
<h3>Limit upload</h3>
Modens DSL ou cabeados tem uma longa fila para melhorar o rendimento de upload. No entanto encher a fila com um dispositivo rápido (ex. ethernet) diminuirá dramáticamente a interatividade. É logo, util para limitar a taxa de upload do dispositivo  para igualar a capacidade do modem, Isso deve melhorar grandemente a interatividade. Defne em torno da máxinma de 90% da velocidade do  modem (cabo).
<h4>Linux</h4>
Para upload em um modem de 512 Kbit.
<pre># tc qdisc add dev eth0 root tbf rate 480kbit latency 50ms burst 1540
# tc -s qdisc ls dev eth0                         <span class="cmt"># Status</span>
# tc qdisc del dev eth0 root                      <span class="cmt"># Exclui a fila</span>
# tc qdisc change dev eth0 root tbf rate 220kbit latency 50ms burst 1540
</pre>
<h4>FreeBSD</h4>
FreeBSD utiliza o <code>dummynet</code> modelador de tráfego que é configurado com o ipfw. Pipes são utilizados para definir os limites da largura de banda em unidades de [K|M]{bit/s|Byte/s}, 0 significa largura de banda ilimitada. Utilizando o mesmo número pipe configurará-lo. Por exemplo, limitar a largura de banda de upload para 500 Kbit.
<pre>
# kldload dummynet                                <span class="cmt"># carrega o módulo se necessário</span>
# ipfw pipe 1 config bw 500Kbit/s                 <span class="cmt"># cria um pipe com a largura de banda limitada</span>
# ipfw add pipe 1 ip from me to any               <span class="cmt"># desvia o upload total para dentro do pipe</span>
</pre>
<h3>Qualidade de serviço</h3>
<h4>Linux</h4>
Fila de prioridade com o  <code>tc</code> para otimizar o VoIP. Veja o exemplo todo em <a rel="nofollow" href="http://www.voip-info.org/wiki-QoS+Linux+with+HFS">voip-info.org</a> ou <a rel="nofollow" href="http://www.howtoforge.com/voip_qos_traffic_shaping_iproute2_asterisk">www.howtoforge.com</a>. Suponhaos que o VoIP utiliza udp nas portas 10000:11024 e o dispositivo eth0 (poderia ser também ppp0 ou outro). Os comandos a seguir definem o QoS para três filas e força o VoIP a trafegar para a fila  1com o QoS <code>0x1e</code> (todos os bits definidos). A configuração padrão flui dentro da fila 3 e o QoS <i>Minimize-Delay</i> flui na fila 2.
<pre># tc qdisc add dev eth0 root handle 1: prio priomap 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 0
# tc qdisc add dev eth0 parent 1:1 handle 10: sfq
# tc qdisc add dev eth0 parent 1:2 handle 20: sfq
# tc qdisc add dev eth0 parent 1:3 handle 30: sfq
# tc filter add dev eth0 protocol ip parent 1: prio 1 u32 \
  match ip dport 10000 0x3C00 flowid 1:1          <span class="cmt"># utiliza o range de porta do servidor</span>
  match ip dst 123.23.0.1 flowid 1:1              <span class="cmt"># ou/e utiliza o IP do servidor</span>
</pre>
Status e remover com
<pre># tc -s qdisc ls dev eth0                         <span class="cmt"># status de fila</span>
# tc qdisc del dev eth0 root                      <span class="cmt"># exclui todo o QoS</span>
</pre>
<h4>Calcular range de porta e mascara</h4>
O tc filter define o range da porta com porta e mascara que você tem que calcular. Encontre o 2^N <i>ending</i> do range da porta, deduza o range e converta para HEX. Essa é a sua máscara. Exemplo para for 10000 -&gt; 11024, o range é 1024.
<pre># 2^13 (8192) &lt; 10000 &lt; 2^14 (16384)              <span class="cmt"># Final é 2^14 = 16384</span>
# echo "obase=16;(2^14)-1024" | bc                <span class="cmt"># mascara é 0x3C00</span>
</pre>

<h4>FreeBSD</h4>
O link maximo de largura de banda é de 500Kbit/s e definimos 3 filas com prioridade 100:10:1 para VoIP:ssh:all the rest.
<pre># ipfw pipe 1 config bw 500Kbit/s 
# ipfw queue 1 config pipe 1 weight 100
# ipfw queue 2 config pipe 1 weight 10
# ipfw queue 3 config pipe 1 weight 1
# ipfw add 10 queue 1 proto udp dst-port 10000-11024
# ipfw add 11 queue 1 proto udp dst-ip 123.23.0.1 <span class="cmt"># ou/e utiliza IP do seridor</span>
# ipfw add 20 queue 2 dsp-port ssh
# ipfw add 30 queue 3 from me to any              <span class="cmt"># todo o resto</span>
</pre>
Status e remover com
<pre># ipfw list                                       <span class="cmt"># status de regras</span>
# ipfw pipe list                                  <span class="cmt"># status do pipe</span>
# ipfw flush                                      <span class="cmt"># exclui todas as regras, menos a padrão</span>
</pre>
<h2 id="nis">Debugar o NIS</h2>
Algums comando que dever funcionar em um cliente NIS bem configurado:
<pre># ypwhich                  <span class="cmt"># obtem o nome do servidor NIS conectado</span>
# domainname               <span class="cmt"># O nome do domínio NIS como está configurado</span>
# ypcat group              <span class="cmt"># deve exibir o grupo a partir do servidor NIS</span>
# cd /var/yp &amp;&amp; make       <span class="cmt"># Reconstroe a base de dados do yp</span>
# rpcinfo -p servername    <span class="cmt"># Reporta os serviços RPC do servidor</span>
</pre>
O ypbind está rodando?
<pre># ps auxww | grep ypbind
/usr/sbin/ypbind -s -m -S servername1,servername2	<span class="cmt"># FreeBSD</span>
/usr/sbin/ypbind           <span class="cmt"># Linux</span>
# yppoll passwd.byname
Map passwd.byname has order number 1190635041. Mon Sep 24 13:57:21 2007
The master server is servername.domain.net.
</pre>
<h3>Linux</h3>
<pre># cat /etc/yp.conf
ypserver servername
domain domain.net broadcast
</pre>

<h2 id="netcat">Netcat</h2>
<a rel="nofollow" href="http://netcat.sourceforge.net/">Netcat</a><span class="fn">http://netcat.sourceforge.net</span> (nc) é melhor conhecido como o "Canivete Suíço de Rede", ele pode manipular, criar ou ler/escrever conexões TCP/IP. Aqui alguns exemplos uteis, há muitos mais na net, por exemplo <a rel="nofollow" href="http://www.g-loaded.eu/2006/11/06/netcat-a-couple-of-useful-examples">g-loaded.eu[...]</a><span class="fn">http://www.g-loaded.eu/2006/11/06/netcat-a-couple-of-useful-examples</span> e <a rel="nofollow" href="http://www.terminally-incoherent.com/blog/2007/08/07/few-useful-netcat-tricks">aqui</a><span class="fn">http://www.terminally-incoherent.com/blog/2007/08/07/few-useful-netcat-tricks</span>.<br /> Você pode precisar usar o comando <code>netcat</code> ao inves do <code>nc</code>. Veja também o comando similar <a rel="nofollow" href="http://www.dest-unreach.org/socat">socat</a>.

<h3>Transferência de arquivo</h3>
Copia um diretório grande atraves de uma conexão tcp bruta. A transferência é bem ráída (sem sobrecarga de protocolo) e vocẽ não precisa  bagunçar com NFS ou SMB ou FTP ou outros, simplesmente torne o arquivo disponível no servidor, e ser obtido a partir do clientea. Aqui 192.168.1.1 é o endereço de Ip do servidor.
<pre><span class="cmt">server#</span> tar -cf - -C VIDEO_TS . | nc -l -p 4444         <span class="cmt"># Serve o arquivo tar na porta 4444</span>
<span class="cmt">client#</span> nc 192.168.1.1 4444 | tar xpf - -C VIDEO_TS     <span class="cmt"># Puxa o arquivo na porta 4444</span>
<span class="cmt">server#</span> cat largefile | nc -l 5678                      <span class="cmt"># Serve um único arquivo</span>
<span class="cmt">client#</span> nc 192.168.1.1 5678 &gt; largefile                 <span class="cmt"># Puxa um único arquivo</span>
<span class="cmt">server#</span> dd if=/dev/da0 | nc -l 4444                     <span class="cmt"># Imagem da partição do servidor</span>
<span class="cmt">client#</span> nc 192.168.1.1 4444 | dd of=/dev/da0            <span class="cmt"># Puxa partição para clonagem</span>
<span class="cmt">client#</span> nc 192.168.1.1 4444 | dd of=da0.img             <span class="cmt"># Puxa partção para o arquivo</span>
</pre>
<h3>Outras hacks</h3>
Especialmente aqui, você deve saber o que está fazendo.
<h4>Shell Remoto</h4>
Opção -e somnente na versão do Windows? Ou utilize <a rel="nofollow" href="http://download.insecure.org/stf/nc110.tgz">nc 1.10</a>.
<pre># nc -lp 4444 -e /bin/bash                        <span class="cmt"># Provê um shell remoto (backdoor de servidor)</span>
# nc -lp 4444 -e cmd.exe                          <span class="cmt"># shell remoto para Windows</span>
</pre>
<h4>Servidor web de emergência</h4>
Serve um único arquivo na 80 em um laço (loop).
<pre># while true; do nc -l -p 80 &lt; unixtoolbox.xhtml; done
</pre>
<h4>Chat</h4>
Alice e Bob podem bater-papo (chat) sobre um simples socket TCP. O texto é transferido com a tecla enter.
<pre><span class="cmt">alice#</span> nc -lp 4444
<span class="cmt">bob  #</span> nc 192.168.1.1 4444
</pre>
</div>

<div id="ssh"><h1><a>SSH SCP</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#publickey">Chave pública</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#sshfingerprint">Fingerprint</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#scp">SCP</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#sshtunnel">Tunelamento</a></p>
Veja outros truques <a href="http://blog.urfix.com/25-ssh-commands-tricks/">25 ssh cmd</a><span class="fn">http://blog.urfix.com/25-ssh-commands-tricks/</span>
<h2 id="publickey">Autenticação de chave pública</h2>
Connecte com um host sem senha utilizando autenticação com chave pública. A ideia é anexar sua chave pública ao arquivo authorized_keys2 no host remoto. Para esse exemplo vamos <b>conectar o <i>host-client</i> ao <i>host-server</i></b>, a chave é gerada no cliente. Com o cygwin você pode ter que criar seu diretório home e o diretório .ssh com<code># mkdir -p /home/USER/.ssh</code>
<ul>
  <li>Utilize o ssh-keygen para gerar um par de chaves. <code>~/.ssh/id_dsa</code> é a chave privada, <code>~/.ssh/id_dsa.pub</code> é a chave pública.</li>
  <li>Copie somente a chave pública ao servidor e anexe-a ao arquivo <code>~/.ssh/authorized_keys2</code> no home do seu servidor.</li>
</ul>
<pre># ssh-keygen -t dsa -N ''
# cat ~/.ssh/id_dsa.pub | ssh you@host-server "cat - &gt;&gt; ~/.ssh/authorized_keys2"
</pre>

<h3>Utilizando o cliente Windows a partir do ssh.com</h3>
A versão não comercial do cliente ssh.com pode ser baixado do ftp pricipal: <a rel="nofollow" href="http://ftp.ssh.com/pub/ssh/">ftp.ssh.com/pub/ssh/</a>. As chaves geradas pelo cliente ssh.com precisam ser convertidas pelo servidor OpenSSH. Isso pode ser feito com o comando ssh-keygen.
<ul>
  <li>Crie um par de chaves com o cliente ssh.com: Configurações - Autenticação de usuário - Gera Nova....</li>
  <li>Eu utilizo chave do tipo DSA; comprimento com chave de 2048.</li>
  <li>Copie a chave pública gerada pelo cliente ssh.com para o servidor dentro do diretório ~/.ssh.</li>
  <li>As chaves estão dentro de C:\Documents and Settings\%USERNAME%\Application Data\SSH\UserKeys.</li>
  <li>Utilize o comando ssh-keygen no servidor para converter a chave:
<pre># cd ~/.ssh
# ssh-keygen -i -f keyfilename.pub &gt;&gt; authorized_keys2
</pre></li>
</ul>

<i>Nota:</i> Utilizamos uam chave DSA, RSA também é possível. A chave não é protegida por uma senha.
<h3>Utilizar o putty para o Windows</h3>
<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">Putty</a><span class="fn">http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html</span> é um cliente ssh simples e livre para Windows. 
<ul>
  <li>Crie um par de chaves com o programa puTTYgen.</li>
  <li>Salve as chaves pública e privada (dentro into C:\Documents and Settings\%USERNAME%\.ssh por exemplo).</li>
  <li>Copie a chave pública no servidor, dentro do diretório ~/.ssh:
    <pre># scp .ssh/puttykey.pub root@192.168.51.254:.ssh/</pre></li>
  <li>Utilize o comando ssh-keygen no servidor para converter a chave para o OpenSSH:
<pre># cd ~/.ssh
# ssh-keygen -i -f puttykey.pub &gt;&gt; authorized_keys2
</pre></li>
<li>Aponte o local a chave privada nas configurações do putty: Conexão - SSH - Auth</li>
</ul>

<h2 id="sshfingerprint">Verificar fingerprint</h2>
No primeiro login, ssh perguntará se o host desconhecido com a impressão digital (fingerprint) tem que ser armazenado nos hosts conhecidos. Para evitar um ataque man-in-the-middle, o administrador do servidor pode te enviar  o fingerprint do servidor que é então comparado no primeiro login. Utilize <code>ssh-keygen -l</code> para obter a fingerprint (no servidor):
<pre># ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub      <span class="cmt"># Para chave RSA</span>
2048 61:33:be:9b:ae:6c:36:31:fd:83:98:b7:99:2d:9f:cd /etc/ssh/ssh_host_rsa_key.pub
# ssh-keygen -l -f /etc/ssh/ssh_host_dsa_key.pub      <span class="cmt"># Para chave DSA (padrão)</span>
2048 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee /etc/ssh/ssh_host_dsa_key.pub
</pre>
Agora o cliente que estiver conectando á esse servidor pode verificar que está conectando ao servidor correto:
<pre># ssh linda
A authenticity of host 'linda (192.168.16.54)' can't be established.
DSA key fingerprint is 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee.
Are you sure you want to continue connecting (yes/no)? yes
</pre>
<h2 id="scp">Transferencia segura de arquivo</h2>
Some simple commands:<br />
<pre># scp file.txt host-two:/tmp
# scp joe@host-two:/www/*.html /www/tmp
# scp -r joe@host-two:/www /www/tmp
</pre>
No Konqueror ou Midnight Commander é possível acessar um sistema de arquivo remoto com o endereço <strong>fish://user@gate</strong>. No entanto a implementação é muito lenta.<br />
Além disso é possível montar uma pasta (um diretório) remoto com <strong>sshfs</strong>, um cliente sistema de arquivo (file system client) baseado no SCP. <a href="http://fuse.sourceforge.net/sshfs.html">Veja fuse sshfs</a><span class="fn">http://fuse.sourceforge.net/sshfs.html</span>.
<pre>ssh_exchange_identification: Connection closed by remote host</pre>
Com esse erro tente o seguinte no servidor:
<pre>echo 'SSHD: ALL' &gt;&gt; /etc/hosts.allow
/etc/init.d/sshd restart</pre>
<h2 id="sshtunnel">Tunelamento</h2>
Tunelamento SSH lhe permite direcionar ou reverter a porta na conexão SSH, assim garantindo o tráfego e acessar portas que caso contrario estariam bloqueada. Isso só funciona com TCP. A nomenclatura geral para direcionamento e reverso é (veja também <a href="http://cb.vu/unixtoolbox.xhtml#sshnat">exemplo de ssh e NAT</a>):
<pre># ssh -L localport:desthost:destport user@gate  <span class="cmt"># desthost como visto a partir do gate</span>
# ssh -R destport:desthost:localport user@gate  <span class="cmt"># direciona a sua porta local para o destino</span>
    <span class="cmt"># desthost:localport como visto a partir do cliente iniciando o túnel</span>
# ssh -X user@gate   <span class="cmt"># Forçar o X direcioar</span>
</pre>
Isso vai conectar ao gate e direcionar a porta local ao host desthost:destport. Note que desthost é o host de destino <i>como visto pelo gate</i>, então se a conexão é para o gate, então desthost é o localhost. Mais do que o direcionamento de uma porta é possível.
<h3>Direcionamento direto no gate</h3>
Digamos que queremos acessar CVS (porta 2401) e http (porta 80) que estão executando no gate. Isso é o exemplo mais simples, desthost é assim o localhost, e nós usamos  a porta 8080 localmente ao inves da 80 então não precisamos ser o root. uma vez que a sessão ssh está aberta, ambos os serviços estão acessiveis nas portas local.
<pre># ssh -L 2401:localhost:2401 -L 8080:localhost:80 user@gate</pre>
<h3>Direcionamento de Netbios e de área de trabalho remota para um segundo servidor</h3>
Diagmos que um servidor smb Windows está porta trás do gate e não está rodando ssh. Precisamos de acesso para o compartilhamento smb e também para a área de trabalho no servidor.
<pre># ssh -L 139:smbserver:139 -L 3388:smbserver:3389 user@gate</pre>
O compartilhamento smb pode agora ser acessado com o \\127.0.0.1\, mas somente se o compartilhamento local for desabilitado, por que <i>to compartilhamento local está escutando na porta 139</i>.<br />
É possível manter o compartilhamento local abilitado, para isso precisamos criar um novo dispositivo virtual com um novo endereço de IP para o tunel, o compartilhamento  smb será conectado nesse endereço. Além disso <i>o RPD local já está escutando na 3389</i>, então nós escolhemos a 3388. Para esse exemplo vamos utilizar o IP virtual de 10.1.1.1.<br />
<ul>
<li>Com o putty utilize a Source port=10.1.1.1:139. É possível criar dispositívos de loop e de túnel múltiplos. No Windows 2000, somente o putty funcionou para mim. No Windows Vista também direcionou para a porta 445 em adição à porta 139. Também no Vista o patch KB942624 impede a porta 445 direcionar, então eu tive que desinstalar esse path no Vista.</li>
<li>Com o cliente ssh.com, desabilite "Allow local connections only". Já que ssh.com vinculará todos os endereços, somente um único compartilhamento pode ser conectado.</li>
</ul>
Agora crie a interface de loopback com o IP 10.1.1.1:
<ul>
<li># System-&gt;Control Panel-&gt;Add Hardware # Yes, Hardware is already connected
# Add a new hardware device (at bottom).</li>
<li># Install the hardware that I manually select # Network adapters # Microsoft , Microsoft Loopback Adapter.</li>
<li>Configure o endereço de IP do dispositivo falso (fake) para o IP 10.1.1.1 máscara 255.255.255.0, sem gateway.</li>
<li>advanced-&gt;WINS, Enable LMHosts Lookup; Disable NetBIOS over TCP/IP.</li>
<li># Abilite o Cliente para as redes Microsofts. # Desabilite Compartilhamento de Arquivo e Impressora para as Redes Microsoft.</li>
</ul>
Eu TIVE que reiniciar para que isso funcionasse. Agora conecte ao compartilhamento smb com \\10.1.1.1 e o remote desktop para 10.1.1.1:3388.
<h4>Debug</h4>
Se isso não estiver funcionando:
<ul>
<li>As portas estão direcionadas: netstat -an? Olhe para 0.0.0.0:139 ou 10.1.1.1:139</li>
<li>O telnet conecta em 10.1.1.1 139?</li>
<li>Você proceisa do checkbox "Local ports accept connections from other hosts" (portas locais aceitam conexões a partir de outros hosts).</li>
<li>O "File and Printer Sharing for Microsoft Networks" está desabilitado na interface loopback?</li>
</ul>

<h3 id="sshnat">Conecte dois clientes atrás do NAT</h3>
Suponhamos que dois clientes por tras de um gateway NAT e o cliente cliadmin tem que conectar ao cliente cliuser (o destino), ambos pode logar ao gate com o ssh e estão rodando linux com o sshd. Você não precisa acessar de qualquer lugar desde que as portas no gate estejam acima do 1024. Nós usamos 2022 no gate. Também desde que o gate seja utilizado localmente, a opção GatewayPorts não é necessaria.<br />
No cliente cliuser (a partir do destino para o gate):
<pre># ssh -R 2022:localhost:22 user@gate            <span class="cmt"># direciona o cliente 22 para o gate:2022</span></pre>
No cliente cliadmin (a partir do host para o gate):
<pre># ssh -L 3022:localhost:2022 admin@gate         <span class="cmt"># direciona o cliente 3022 para o gate:2022</span></pre>
Agora o admin pode conectar diretamente ao cliente cliuser com:
<pre># ssh -p 3022 admin@localhost                   <span class="cmt"># local:3022 -&gt; gate:2022 -&gt; client:22</span></pre>

<h3>Conect ao VNC atrás do NAT</h3>
Suponhamos que um cliente Windows com VNC escutando na porta 5900 tem que ser acessado a partir do NAT.
No cliente cliwin para o gate:
<pre># ssh -R 15900:localhost:5900 user@gate</pre>
No cliente cliadmin (a partir do host para o gate):
<pre># ssh -L 5900:localhost:15900 admin@gate</pre>
Agora o admin pode conectar diretamente ao cliente VNC com:
<pre># vncconnect -display :0 localhost</pre>

<h3 id="sshmultihop">Cave (Dig) um tunel ssh multi-hop</h3>
Suponhamos que você não consiga alcançar um servidor diretamente com o ssh, mas somente via multiplos hosts intermediários (por questões de roteamento por exemplo). Algumas vezes é necessário obter uma conexão direta  cliente - servidor, por exemplo para compiar arquicos com o scp, ou direcionar outras portas como smb ou vnc. 
Um jeito de fazer isso é acorrentar túneis (chain tunnels together) para direcionar uma porta para o servidor ao longo dos saltos. Essa porta "carrier" somente alcança seu destino final na ultima conexão para o servidor.<br />
Suponhamos que queremos direcionar a porta ssh de um cliente para um servidor em dois saltos (hops). Um vez que o tunel é construido, é possível conectar ao servidor diretamente do cliente (e também adicionar um outra porta de direcionamento).
<h4>Cria tunel em um shell</h4>
cliente -&gt; host1 -&gt; host2 -&gt; servidor e cave (dig) o túnel 5678
<pre><span class="cmt">client&gt;</span># ssh -L5678:localhost:5678 host1        <span class="cmt"># 5678 é uma porta arbitraria para o túnel</span>
<span class="cmt">host_1&gt;</span># ssh -L5678:localhost:5678 host2        <span class="cmt"># acorrenta 5678 do host1 para o host2</span>
<span class="cmt">host_2&gt;</span># ssh -L5678:localhost:22 server         <span class="cmt"># termina o túnel na porta 22 no server</span>
</pre>
<h4>Use o túnel com um outro shell</h4>
cliente -&gt; servidor utilizando o túnel 5678
<pre># ssh -p 5678 localhost                         <span class="cmt"># conecta diretamente do cliente para o servidor</span>
# scp -P 5678 myfile localhost:/tmp/            <span class="cmt"># ou copie um arquivo diretamente utilizando o túnel</span>
# rsync -e 'ssh -p 5678' myfile localhost:/tmp/ <span class="cmt"># ou utilizando rsync em um arquivo diretamente ao servidor</span>
</pre>
<h3>Script de autoconectar e manter vivo (keep alive)</h3>
Eu utilizo variações do segunte script para mantes a máquina alcancável no túnel ssh reverso. A conexão é automaticamente reconstruída e fechada. Você pode adicionar multiplos túneis <code>-L</code> ou <code>-R</code> em uma linha.
<pre>#!/bin/sh
COMMAND="ssh -N -f -g -R 3022:localhost:22 colin@cb.vu"
pgrep -f -x "$COMMAND" &gt; /dev/null 2&gt;&amp;1 || $COMMAND
exit 0
</pre>
<pre>1 * * * * colin /home/colin/port_forward.sh     <span class="cmt"># entrada crontab (aqui de hora em hora)</span></pre>
</div>

<div id="vpn"><h1><a>VPN com SSH</a></h1>
Como na verão 4.3, o OpenSSH pode usar o dispositivo tun/tap para criptografar um túnel. Ele é bem similar as outras soluções TLS baseado em VPN como o OpenVPN. Uma vantagem do SSH é que não há necessidade de instalar e configurar software adicional. Adicionalmente o túnel utiliza a autenticação SSH como chaves pré-compartilhadas. A desvantagem é que o encapsulamento é feito em TCP que pode resultar em desempenho pobre em um link lento. O túnel também conta com uma única conexão TPC (frágil).  Essa  técnica é muito útil para uma raṕida configuração VPN baseada em IP. Não há limitação como com um único direcionamento de porta TCP, todos os protocolos de camada 3/4 como ICMP, TCP/UDP, etc. são direcionadas no VPN. Em todo caso, as seguintes opções são necessárias no arquivo sshd_conf:
<pre>PermitRootLogin yes
PermitTunnel yes
</pre>

<h2 id="sshp2p">Conexão única P2P</h2>
Aqui vamos conetcar dois hosts, hclient e hserver com o t´unel ponto a ponto (peer to peer tunnel). A conexão é <i>iniciada do hclient</i> para o hserver e é feita como root. Os pontos finais do túnel estão em 10.0.1.1 (servidor) e 10.0.1.2 (cliente) e nós ciramos um dispositivo tun5 (Esse poderia também ter sido um outro número). O procedimento é muito simples:
<ul>
  <li>Conect com o SSH utilizando a opção -w do túnel</li>
  <li>Configure o endereço IP do túnel. Uma vez no servidor e uma vez no cliente.</li>
</ul>
<h3>Conect ao servidor</h3>
A conexão iniciada no cliente e os comandos são executados no servidor.
<h4>No servidor Linux</h4>
<pre><span class="cmt">cli&gt;#</span> ssh -w5:5 root@hserver
<span class="cmt">srv&gt;#</span> ifconfig tun5 10.0.1.1 netmask 255.255.255.252   <span class="cmt"># Executdo no shell do servidor</span>
</pre>
<h4>No srevidor FreeBSD</h4>
<pre><span class="cmt">cli&gt;#</span> ssh -w5:5 root@hserver
<span class="cmt">srv&gt;#</span> ifconfig tun5 10.0.1.1 10.0.1.2                  <span class="cmt"># Executado no shell do servidor</span>
</pre>

<h3>Configure o cliente</h3>
Comandos executados no cliente:
<pre><span class="cmt">cli&gt;#</span> ifconfig tun5 10.0.1.2 netmask 255.255.255.252   <span class="cmt"># Cliente no Linux</span>
<span class="cmt">cli&gt;#</span> ifconfig tun5 10.0.1.2 10.0.1.1                  <span class="cmt"># Cliente no FreeBSD</span>
</pre>
Os dois hosts estão agora conhectados e podem transparentemente comunicar com qualquer protocolo de camada 3/4 utilizando o endereço de IP do túnel.

<h2 id="sshg2g">Conectar duas redes</h2>
Em adição a configuração p2p acima, é mais útil conectar duas redes privadas com uma VPN SSH utilizando dois gates. Suponhamos por exemplo, netA seja 192.168.51.0/24 e netB 192.168.16.0/24. O procedimento é similar ao acima, precisamos somente adicionar o reteamento. O NAT deve ser ativado na interface privada somente se os gates não forem os mesmos que o gateway padrão de sua rede.<br />
192.168.51.0/24 (netA)|gateA &lt;-&gt; gateB|192.168.16.0/24 (netB)<br />
<ul>
  <li>Conecte com o SSH utilizando a opção -w do túnel.</li>
  <li>Configure o endereço IP do túnel. Uma vez no servidor e uma vez no cliente.</li>
  <li>Adicione o roteamento para as duas redes.</li>
  <li>Se necessário, ative o NAT na interafce privada do gate.</li>
</ul>
A configuração é <i>iniciada a partir do gateA no netA</i>.
<h3>Conecte do gateA ao gateB</h3>
Conexão é iniciada do gateA e os comandos são executador no gateB.
<h4>gateB está no Linux</h4>
<pre><span class="cmt">gateA&gt;#</span> ssh -w5:5 root@gateB
<span class="cmt">gateB&gt;#</span> ifconfig tun5 10.0.1.1 netmask 255.255.255.252 <span class="cmt"># Executado no shall do gateB</span>
<span class="cmt">gateB&gt;#</span> route add -net 192.168.51.0 netmask 255.255.255.0 dev tun5
<span class="cmt">gateB&gt;#</span> echo 1 &gt; /proc/sys/net/ipv4/ip_forward        <span class="cmt"># Somente necessário se não for padrão (default gw)</span>
<span class="cmt">gateB&gt;#</span> iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</pre>
<h4>gateB está no FreeBSD</h4>
<pre><span class="cmt">gateA&gt;#</span> ssh -w5:5 root@gateB                          <span class="cmt"># Cria os dispositivos do tun5</span>
<span class="cmt">gateB&gt;#</span> ifconfig tun5 10.0.1.1 10.0.1.2               <span class="cmt"># Executado no shell do gateB</span>
<span class="cmt">gateB&gt;#</span> route add 192.168.51.0/24 10.0.1.2
<span class="cmt">gateB&gt;#</span> sysctl net.inet.ip.forwarding=1               <span class="cmt"># Somente necessário se não for padrão (default) gw</span>
<span class="cmt">gateB&gt;#</span> natd -s -m -u -dynamic -n fxp0                <span class="cmt"># vejasee <a class="xref" href="http://cb.vu/unixtoolbox.xhtml#nat">NAT</a></span>
<span class="cmt">gateA&gt;#</span> sysctl net.inet.ip.fw.enable=1
</pre>

<h3>Configure o gateA</h3>
Comandos executdos no gateA:
<h4>gateA está no Linux</h4>
<pre><span class="cmt">gateA&gt;#</span> ifconfig tun5 10.0.1.2 netmask 255.255.255.252
<span class="cmt">gateA&gt;#</span> route add -net 192.168.16.0 netmask 255.255.255.0 dev tun5
<span class="cmt">gateA&gt;#</span> echo 1 &gt; /proc/sys/net/ipv4/ip_forward
<span class="cmt">gateA&gt;#</span> iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</pre>
<h4>gateA está no FreeBSD</h4>
<pre><span class="cmt">gateA&gt;#</span> ifconfig tun5 10.0.1.2 10.0.1.1
<span class="cmt">gateA&gt;#</span> route add 192.168.16.0/24 10.0.1.2
<span class="cmt">gateA&gt;#</span> sysctl net.inet.ip.forwarding=1
<span class="cmt">gateA&gt;#</span> natd -s -m -u -dynamic -n fxp0                <span class="cmt"># veja <a class="xref" href="http://cb.vu/unixtoolbox.xhtml#nat">NAT</a></span>
<span class="cmt">gateA&gt;#</span> sysctl net.inet.ip.fw.enable=1
</pre>
As duas redes privadas agora estão transparentemente conectadas via VPN SSH. O direcionamento de IP e as configurações NAT são necessárias somente se os gates não forem os gateways padrões. Nesse caso os cliente não saberiam para aonde direcionar a resposta, e o nat deve ser ativado.
</div>

<div id="rsync"><h1><a>RSYNC</a></h1>
Rsync pode quase substituir completamente o cp e o scp, além disso transferencias initerruptas são reinciadas eficientemente. Uma barra invertida (e mesmo a ausência) tem sentidos diferentess, a man page é boa... aqui alguns exemplos:<br />
Copia os diretórios com conteúdo completot:
<pre># rsync -a /home/colin/ /backup/colin/                <span class="cmt"># "archive" mode. ex. mantem o mesmo</span>
# rsync -a /var/ /var_bak/
# rsync -aR --delete-during /home/user/ /backup/      <span class="cmt"># usa relativo (veja abaixo)</span>
# /opt/local/bin/rsync -azv --iconv=UTF-8-MAC,UTF-8 ~/Music/flac/ me@server:/dst/
                           <span class="cmt"># converte nomes de arquivos (filenames) UTF8 do OSX para UTF8 do Windows</span>
</pre>
O meso que o anterior, mas na rede e com compressão. Rsync utiliza SSH para o transporte por padrão e utilizará a chave ssh se elas forem definidas. Utilize ":" da mesma forma que no SCP. Uma copia remota típica:
<pre># rsync -axSRzv /home/user/ user@server:/backup/user/ <span class="cmt"># Copia para um lugar remoto</span>
# rsync -a 'user@server:My\ Documents' My\ Documents  <span class="cmt"># Quote AND escape spaces para o shell remoto</span></pre>
Exclui qualquer diretório tmp dentro de /home/user/ e mantem a hierarquia de pastas (diretórios) relativa, que é o diretório remoto terá a estrutura /backup/home/user/. Isso é tipicamente utilizado para backups.
<pre># rsync -azR --exclude=tmp/ /home/user/ user@server:/backup/</pre>

Utilize a porta 20022 para a conexão ssh:
<pre># rsync -az -e 'ssh -p 20022' /home/colin/ user@server:/backup/colin/</pre>
Utilizando a daemon rsync (ustilizado com "::") é muito mais rápido, mas não cripitografado no ssh. O local do /backup é definido pela configuração em /etc/rsyncd.conf. A variável RSYNC_PASSWORD pode ser difinida para evitar a necessidade de entrar com a senha manualente.
<pre># rsync -axSRz /home/ ruser@hostname::rmodule/backup/
# rsync -axSRz ruser@hostname::rmodule/backup/ /home/    <span class="cmt"># To copy back</span>
</pre>
Algumas opções importantes:
<ul style="list-style-type: none;">
  <li><code>-a, --archive</code>       modo de arquivação (archive mode); o mesmo que -rlptgoD (sem -H)</li>
  <li><code>-r, --recursive</code>       recursivo dentro dos diretórios</li>
  <li><code>-R, --relative</code>       utiliza nomes de caminhos relativos</li>
  <li><code>-H, --hard-links</code>       preserva os hard links</li>
  <li><code>-S, --sparse</code>       manipula eficientemente arquivos dispersos</li>
  <li><code>-x, --one-file-system</code>       não ultrapassa os limites do file system</li>
  <li><code> --exclude=PATTERN</code>       exclui combinações PATTERN (PADRÃO) de arquivos</li>
  <li><code> --delete-during</code>       receiver exclui durante o xfer, não antes</li>
  <li><code> --delete-after</code>       receiver exclui depois de transferir, não antes</li>
</ul>

<h2 id="winrsync">Rsync no Windows</h2>
Rsync está disponível para Windows através do cygwin ou como um pacote stand-alone em <a href="http://sourceforge.net/projects/sereds/">cwrsync</a><span class="fn">http://sourceforge.net/projects/sereds</span>. Isso é muito conveniente para backups automátizados. Instale um deles (<i>não ambos</i>) e adicione o path (caminho) ao sistema de variáveis do Windows (Windows system variables): # Control Panel -&gt; System -&gt; tab Advanced, button Environment Variables. Edite o sistema de variável "Path" e adicione o caminho completo (full path) ao rsync instalado, ex. C:\Program Files\cwRsync\bin or C:\cygwin\bin. Dessa forma os comandos <code>rsync</code> e <code>ssh</code> ficam disponíveis em um shell de comandos do Windows.
<h3>Autenticaçaõ de chave pública</h3>
Rsync é automaticamente tunelado no SSH e assim utiliza a autenticação SSH no servidor. Backups automaticos tem que evitar a interação de um usuário, para isso a autenticação de chave pública do SSH podem ser usadas e o comando rsync rodará sem uma senha.<br />
Todos os comandos a seguir são executados dentro de um console Windows. Em um console (Start -&gt; Run -&gt; cmd) crie e faça upload da chave como descrito em <a href="http://cb.vu/unixtoolbox.xhtml#ssh">SSH</a>, altere "user" e "server" como apropriado. Se o arquivo authorized_keys2 não exista ainda, simplesmente copie id_dsa.pub para authorized_keys2 e suba-a.
<pre># ssh-keygen -t dsa -N ''                   <span class="cmt"># Crie uma chave pública e uma privada</span>
# rsync user@server:.ssh/authorized_keys2 . <span class="cmt"># Copie o arquivo localmente a partir do servidor</span>
# cat id_dsa.pub &gt;&gt; authorized_keys2        <span class="cmt"># Ou utilize um editor to adcionar a chave</span>
# rsync authorized_keys2 user@server:.ssh/  <span class="cmt"># Copie o arquivo de volta para o servidor</span>
# del authorized_keys2                      <span class="cmt"># Remova a copia local</span>
</pre>
Agora teste com (em uma linha):
<pre>rsync -rv "/cygdrive/c/Documents and Settings/%USERNAME%/My Documents/" \
'user@server:My\ Documents/'
</pre>
<h3>Backup automático</h3>
Use um arquivo batch automatizar o backup e adicione o arquivo nas tarefas agendadas (scheduled tasks) (Programs -&gt; Accessories -&gt; System Tools -&gt; Scheduled Tasks). Por exemplo crie o arquivo backup.bat e substitua user@server.
<pre>@ECHO OFF
REM rsync the directory My Documents
SETLOCAL
SET CWRSYNCHOME=C:\PROGRAM FILES\CWRSYNC
SET CYGWIN=nontsec
SET CWOLDPATH=%PATH%
REM uncomment the next line when using cygwin
SET PATH=%CWRSYNCHOME%\BIN;%PATH%
echo Press Control-C to abort
rsync -av "/cygdrive/c/Documents and Settings/%USERNAME%/My Documents/" \
'user@server:My\ Documents/'
pause
</pre>
</div>

<div id="sudo"><h1><a>SUDO</a></h1>
Sudo é um modo padrão para conceder aos ususários alguns direitos administrativos sem fornecer a senha de root. Sudo é muito util em um ambiente multiusuário com um mescla de servidores e workstations. Simplesmente chame o comando com o sudo:
<pre># sudo /etc/init.d/dhcpd restart            <span class="cmt"># Rode o script rc como root</span>
# sudo -u sysadmin whoami                   <span class="cmt"># Rode o cmd como um outro usuário</span>
</pre>
<h2>Configuração</h2>
Sudo é configurado em <code>/etc/sudoers</code> e deve ser editado comente com o <code>visudo</code>. A syntax básica é (as listas são seaparadas por virgula):
<pre>user hosts = (runas) commands          <span class="cmt"># Em /etc/sudoers</span></pre>        
<ul style="list-style-type:none; page-break-inside:avoid;">
  <li><code>users</code> um ou mais usuários ou %group (como %wheel) para ganhar os direitos</li>
  <li><code>hosts</code> lista de hosts (ou ALL)</li>
  <li><code>runas</code> lista de usuários (ou ALL) que a regra de comando pode ser rodado como. É cercado em ( )!</li>
  <li><code>commands</code> lista de comandos (or ALL) que serão rodados como root ou como (runas)</li>
</ul>
Adicionalmente aquelas palavras chave pode ser definidas como alias, ela são chamadas User_Alias, Host_Alias, Runas_Alias e Cmnd_Alias. Isso é util para instalações maiores. Aqui um exemplo sudoers:
<pre># cat /etc/sudoers
<span class="cmt"># Host aliases são subnets ou hostnames.</span>
Host_Alias   DMZ     = 212.118.81.40/28
Host_Alias   DESKTOP = work1, work2

<span class="cmt"># User aliases é uma lista de usuários que podem ter os mesmos direitos</span>
User_Alias   ADMINS  = colin, luca, admin
User_Alias   DEVEL   = joe, jack, julia
Runas_Alias  DBA     = oracle,pgsql

<span class="cmt"># Comando aliases define o caminho completo de uma lista de comandos</span>
Cmnd_Alias   SYSTEM  = /sbin/reboot,/usr/bin/kill,/sbin/halt,/sbin/shutdown,/etc/init.d/
Cmnd_Alias   PW      = /usr/bin/passwd [A-z]*, !/usr/bin/passwd root <span class="cmt"># Não pwd do root!</span>
Cmnd_Alias   DEBUG   = /usr/sbin/tcpdump,/usr/bin/wireshark,/usr/bin/nmap
</pre><pre><span class="cmt"># As reais regras</span>
root,ADMINS  ALL     = (ALL) NOPASSWD: ALL    <span class="cmt"># ADMINS podem fazer qualquer coisa com/ou um senha.</span>
DEVEL        DESKTOP = (ALL) NOPASSWD: ALL    <span class="cmt"># Desenvolvedore tem totoal direito nos desktops</span>
DEVEL        DMZ     = (ALL) NOPASSWD: DEBUG  <span class="cmt"># Desenvolvedores podem debugar os servidores DMZ.</span>

<span class="cmt"># Usuário sysadmin pode mexer por aí nos servidores DMZ com alguns comandos.</span>
sysadmin     DMZ     = (ALL) NOPASSWD: SYSTEM,PW,DEBUG
sysadmin     ALL,!DMZ = (ALL) NOPASSWD: ALL   <span class="cmt"># Pode fazer qualquer coisa fora do DMZ.</span>
%dba         ALL     = (DBA) ALL              <span class="cmt"># Grupo dba pode rodar como usuário database.</span>

<span class="cmt"># qualquer um pode montar/desmontar um cd-rom nas máquinas desktop</span>
ALL          DESKTOP = NOPASSWD: /sbin/mount /cdrom,/sbin/umount /cdrom
</pre> 

</div>

<div id="crypt"><h1><a>Arquivos criptografados</a></h1>
<h2>OpenSSL</h2>
<h3>Um único arquivo</h3>
Criptograr e descriptografar:
<pre># openssl aes-128-cbc -salt -in file -out file.aes
# openssl aes-128-cbc -d -salt -in file.aes -out file
</pre>
Note que o arquivo pode é claro ser um arquivo tar (tar archive).
    
<h3>tar e criptografar um diretório completo</h3>
<pre># tar -cf - directory | openssl aes-128-cbc -salt -out directory.tar.aes      <span class="cmt"># Criptografado</span>
# openssl aes-128-cbc -d -salt -in directory.tar.aes | tar -x -f -            <span class="cmt"># Descriptografado</span>
</pre>
    
<h3>tar zip e criptografar um diretório completo</h3>
<pre># tar -zcf - directory | openssl aes-128-cbc -salt -out directory.tar.gz.aes  <span class="cmt"># Criptografado</span>
# openssl aes-128-cbc -d -salt -in directory.tar.gz.aes | tar -xz -f -        <span class="cmt"># Descriptografado</span>
</pre>

<ul>
<li>Utilize -k mysecretpassword depois de aes-128-cbc para evitar solicitação de senha interativa. No entando note que isso é altamente inseguro.</li>
<li>Utilize <strong>aes-256-cbc</strong> ao inves de <strong>aes-128-cbc</strong> para obter criptografia ainda mais forte. Isso utiliza também mais CPU.</li>
</ul>

<h2>GPG</h2>
<a href="http://gnupg.org/">GnuPG</a> é bem conhecido para criptografar e assinalar emails ou qualquer dado. Além do mais gpg também provê um sistema avançado de gerenciamento chaves. Essa seçã cobre somente criptografia de arquivos, não uso de email, assinalar ou o Web-Of-Trust.<br />
A criptografia mais simples é com uma symmetric cipher. Nesse cado o arquivo é criptografado com uma senaha e qualquer um que saiba a senha pode descriptografá-lo, assim as chaves não são necessárias. Gpg adiciona uma extenção ".gpg" para os nomes do arquivos criptogrados.
<pre># gpg -c file                        <span class="cmt"># Criptografa arquivo com senha</span>
# gpg file.gpg                       <span class="cmt"># Desciptografa arquivo (opcionalmente -o otherfile)</span>
</pre>
<h3>Utizando chaves (keys)</h3>
Para mais detalhess veja <a href="http://www.madboa.com/geek/gpg-quickstart">GPG Quick Start</a><span class="fn">http://www.madboa.com/geek/gpg-quickstart</span> e <a href="http://aplawrence.com/Basics/gpg.html">GPG/PGP Basics</a><span class="fn">http://aplawrence.com/Basics/gpg.html</span> e o <a href="http://gnupg.org/documentation">gnupg documentation</a><span class="fn">http://gnupg.org/documentation</span> entre outros.<br />
As chaves privadas e públicas são o coração da criptografia asimétrica. O que é importante lembrar:
<ul>
<li>Sua chave pública é usada por <i>outros</i> para criptografar arquivos que somente você como o receptor pode descriptografar (não somente aquele que criptografou o arquivo que pode descritografá-lo). A chave pública tem assim que distribuída.</li>
<li>Sua chave privada é criptografada com a sua passphrase e é utilizada para descriptografar arquvos que foram criptografadas com a <i>your</i> chave pública. A chave privada deve ser guardada <b>segura</b>. Se a chave ou passphrase for perdida, todos os arquivos criptografados e chaves públicas também são.</li>
<li>Os arquvos chaves são chamados keyrings (chaveiros) já que eles podem conter mais que uma chave.</li>
</ul>
Primeiro gere o pare de chaves. As padrões são boas, no entanto você terá que inserir ao menos seu nome completo e email e opcionalmente um comentário. O comentário é util para criar mais do que uma chave com o mesmo email. Você deve também utilizar uma "passphrase", não uma senha simples.
<pre># gpg --gen-key                      <span class="cmt"># Isso pode levar um tempo</span></pre>
As chaves são armazenadas em ~/.gnupg/ no Unix, no Windows elas são tipicamente armazenadas em<br />
C:/Documents and Settings/%USERNAME%/Application Data/gnupg/.
<pre>~/.gnupg/pubring.gpg                 <span class="cmt"># Contem suas chaves públicas e todas as outras importadas</span>
~/.gnupg/secring.gpg                 <span class="cmt"># Pode conter mais de uma chave privada</span>
</pre>
Curto lembrete nas opções mais utilizadas:
<ul style="list-style-type:none; page-break-inside:avoid;">
  <li><b>-e</b> criptografa dado</li>
  <li><b>-d</b> descriptografa dado</li>
  <li><b>-r</b> NAME criptografa para o recipiente NAME (ou 'Full Name' ou 'email@domain')</li>
  <li><b>-a</b> cria saída blindada ascii de uma chave</li>
  <li><b>-o</b> utiliza com arquivo de saída</li>
</ul>
O exemplo utiliza 'Your Name' e 'Alice' já que as chaves são referidas pelo email ou nome completo ou nome parcial. Por exemplo eu posso utilizar 'Colin' ou 'c@cb.vu' para a minha have [Colin Barschel (cb.vu) &lt;c@cb.vu&gt;].
<h3>Criptografa somente para uso pessoal</h3>
Não necesita exportar/importar qualquer chave para isso. Você já possui ambas.
<pre># gpg -e -r 'Your Name' file                  <span class="cmt"># Criptografa com a sua chave pública</span>
# gpg -o file -d file.gpg                     <span class="cmt"># Descriptografa. Utiliza -o ou vai para a saída</span>
</pre>
<h3>Criptografar - Descriptografar com chaves</h3>
Primeiro você precisa exportar sua chave pública para que mais alguém a utilize. E você precisa importar a pública, digamos a partir da Alice para criptografar um arquivo para ela. Você pode tanto manusear as chaves em simples arquivos ascii ou utilizar um servidor de chave pública.<br />
Por exemplo, Alice exportou sua chave pública e você a importou, você oide criptografar um arquivo para ela. Isso é, somente Alice será capaz de descriptogrfá-lo.
<pre># gpg -a -o alicekey.asc --export 'Alice'     <span class="cmt"># Alice exportou sua chave em arquivo ascii.</span>
# gpg --send-keys --keyserver subkeys.pgp.net KEYID   <span class="cmt"># Alice colocou sua chave em um servidor.</span>
# gpg --import alicekey.asc                   <span class="cmt"># Você import a chave da Alice para dentro do seu pubring.</span>
# gpg --search-keys --keyserver subkeys.pgp.net 'Alice' <span class="cmt"># ou obtenha a chave a Alice a partir do servidor.</span>
</pre>
Uma vez as chaves importadas, é muito fácil criptografar ou descriptografar um arquivo:
<pre># gpg -e -r 'Alice' file                      <span class="cmt"># Criptografa o arquivo para a Alice.</span>
# gpg -d file.gpg -o file                     <span class="cmt"># Descriptografa um arquivo (criptografado pela Alice) para você.</span>
</pre>
<h3>Administração de chave</h3>
<pre># gpg --list-keys                             <span class="cmt"># lista chaves públicas e vê o KEYIDS</span>
    <span class="cmt">The KEYID follows the '/' e.g. for: pub   1024D/D12B77CE the KEYID is D12B77CE</span>
# gpg --gen-revoke 'Your Name'                <span class="cmt"># gera certificado de revocação</span>
# gpg --list-secret-keys                      <span class="cmt"># lista chaves privadas</span>
# gpg --delete-keys NAME                      <span class="cmt"># exclui uma chave pública a partir do chaveiro local (key ring)</span>
# gpg --delete-secret-key NAME                <span class="cmt"># eclui uma chave secreta a partir do chaveiro local</span>
# gpg --fingerprint KEYID                     <span class="cmt"># Exibe a impressão digital (fingerprint) da chave</span>
# gpg --edit-key KEYID                        <span class="cmt"># Edita a chave (ex. assina ou adiciona/exclui email)</span>
</pre>

</div>

<div id="cryptpart"><h1><a>Criptografar Partições</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#wluks">Linux com LUKS</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#woluks">Linux dm-crypt (somente)</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#bsdgeli">FreeBSD GELI</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#bsdpwd">FBSD pwd (somente)</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#osxcrypt">Imanegm OS X</a></p>
Há (muitos) outros métodos de alternativa para criptografar discos, eu mostro aqui somente os metodos que conheço e utilizo. Tenha em mente que segurança só é boa desde que o OS não foi s no been tempered with. Um intruso poderia facilmente gravar a senha a partir de eventos teclado. Além do mais o dado é livremente acessível quando a partição for <i>attached</i> e não evitará que um intruso tenha acesso á isso nesse estado.
<h2 id="dm-crypt">Linux</h2>
Essas intrunções utilizam o Linux <code>dm-crypt</code> (device-mapper ou mapeador de dispositivo) facilidade dispoível no kernel 2.6. Nesse exemplo, vamos criptografar a partição <code>/dev/sdc1</code>, poderia no entando ser qualquer outra partição ou disco, ou USB ou uma partição baseada em arquivo criada com <code>losetup</code>. Nesse caso poderias usar <code>/dev/loop0</code>. Veja <a href="http://cb.vu/unixtoolbox.xhtml#losetup">file image partition</a>. O mapeador de dispositivo utiliza etiquetas (labels) para identificar uma partição. Nós utilizamos <code>sdc1</code> nesse exemplo, mas poderia ser qualquer string.
<h3 id="wluks">dm-crypt com o  LUKS</h3>
LUKS com dm-crypt tem melhor criptografia e torna possível ter multiplas passphrase para a mesma partição ou alterar a senha facilmente. para testar se o LUKS está disponível, simplesmente digite <code># cryptsetup --help</code>, se nada a respeito do LUKS for exibido, use as instruções abaixo <a href="http://cb.vu/unixtoolbox.xhtml#woluks">Without LUKS</a>. Primeiro crie uma partição se necessário: <code>fdisk /dev/sdc</code>.
<h4>Criar partição criptografada</h4>
<pre># dd if=/dev/urandom of=/dev/sdc1          <span class="cmt"># Opcional. For paranoids only (leva dias)</span>
# cryptsetup -y luksFormat /dev/sdc1       <span class="cmt"># Isso destroi qualquer dado no sdc1</span>
# cryptsetup luksOpen /dev/sdc1 sdc1
# mkfs.ext3 /dev/mapper/sdc1               <span class="cmt"># cria sistema de arquivo ext3</span>
# mount -t ext3 /dev/mapper/sdc1 /mnt
# umount /mnt
# cryptsetup luksClose sdc1                <span class="cmt"># Desanexar a partição criptografada</span></pre>
<h4>Anexar</h4>
<pre># cryptsetup luksOpen /dev/sdc1 sdc1
# mount -t ext3 /dev/mapper/sdc1 /mnt</pre>
<h4>Desanexar</h4>
<pre># umount /mnt
# cryptsetup luksClose sdc1
</pre>
<h3 id="woluks">dm-crypt sem LUKS</h3>
<pre># cryptsetup -y create sdc1 /dev/sdc1      <span class="cmt"># ou qualquer outra partição como /dev/loop0</span>
# dmsetup ls                               <span class="cmt"># verifica, exibirá: sdc1 (254, 0)</span>
# mkfs.ext3 /dev/mapper/sdc1               <span class="cmt"># Isso é feito somente a primeira vez!</span>
# mount -t ext3 /dev/mapper/sdc1 /mnt
# umount /mnt/
# cryptsetup remove sdc1                   <span class="cmt"># Desanexar a partição criptografada</span>
</pre>
Faz exatamente o mesmo (sem a parte do mkfs!) para re-anexar a partição. Se a senha não estiver correta, o comando mount falhará. Nesse caso simplesmente remova o map sdc1 (<code>cryptsetup remove sdc1</code>) e crie-a novamente.
<h2 id="bsdgeli">FreeBSD</h2>
Os dois modulos de criptografia de disco populares do FreeBSD são o <code>gbde</code> e <code>geli</code>. Agora eu utilizo o geli por que ele é mais rápido e também utiliza o crypto device para aceleração de hardware. Veja o <a href="http://www.freebsd.org/handbook/disks-encrypting.html">FreeBSD handbook Chapter 18.6</a><span class="fn">http://www.freebsd.org/handbook/disks-encrypting.html</span> para todos os detalhes. o módulo geli deve ser carregado ou compilado dentro do kernel:
<pre>options GEOM_ELI
device crypto                                       <span class="cmt"># ou como modulo:</span>
# echo 'geom_eli_load="YES"' &gt;&gt; /boot/loader.conf   <span class="cmt"># ou faça: kldload geom_eli</span>
</pre>
<h3>Utilizar senha e chave</h3>
Eu utilizo essas configurações para uma criptografia de disco tipica, ela utiliza uma passphrase AND uma chave para criptografar a chave mestre (master). Isso é, você precisa tanto da senha e quando da chave gerada <code>/root/ad1.key</code> para anexaar a partição. A chave mestre fica armazenada dentro da partição e não fica visivel. Veja abaixo para USB tipico ou imagem baseada em arquivo.
<h4>Criar partição criptografada</h4>
<pre>
# dd if=/dev/random of=/root/ad1.key bs=64 count=1  <span class="cmt"># Essa chave criptografa a chave mestre</span>
# geli init -s 4096 -K /root/ad1.key /dev/ad1       <span class="cmt"># -s 8192 também é bom para discos</span>
# geli attach -k /root/ad1.key /dev/ad1             <span class="cmt"># FAÇA um backup de /root/ad1.key</span>
# dd if=/dev/random of=/dev/ad1.eli bs=1m           <span class="cmt"># Opcional e leva um bom tempo</span>
# newfs /dev/ad1.eli                                <span class="cmt"># Cria sistema de arquivo</span>
# mount /dev/ad1.eli /mnt
</pre>
<h4>Anexar</h4>
<pre># geli attach -k /root/ad1.key /dev/ad1
# fsck -ny -t ffs /dev/ad1.eli                      <span class="cmt"># na dúvida verifique o sistema de arquivo</span>
# mount /dev/ad1.eli /mnt
</pre>
<h4>Desanexar</h4>
o procedimento de desanexação é feito automaticamente no shutdown.
<pre># umount /mnt
# geli detach /dev/ad1.eli
</pre>
<h4>/etc/fstab</h4>
A partiçao criptografada pode ser configurada para ser montada com /etc/fstab. A senha será solicitada quando bootar. As seguintes configurações são exigidas para esse exemplo:
<pre># grep geli /etc/rc.conf
geli_devices="ad1"
geli_ad1_flags="-k /root/ad1.key"
# grep geli /etc/fstab
/dev/ad1.eli         /home/private              ufs             rw      0       0
</pre>
<h3 id="bsdpwd">Usar somente a senha</h3>
É mais conveniente criptografar um pendrive ou imagem baseada em arquivo com somente uma passphrase e sem chave. Nesse caso não é necessário carregar o arquivo de chave adicional por aí. O procedimento é o bem como o acima, simplesmente sem o arquivo chave. Vamos criptografar uma imagem baseada em arquivo <code>/cryptedfile</code> de 1 GB.
<pre># dd if=/dev/zero of=/cryptedfile bs=1M count=1000  <span class="cmt"># Arquivo de 1 GB</span>
# mdconfig -at vnode -f /cryptedfile
# geli init /dev/md0                                <span class="cmt"># criptografa somente com senha</span>
# geli attach /dev/md0
# newfs -U -m 0 /dev/md0.eli
# mount /dev/md0.eli /mnt
# umount /dev/md0.eli
# geli detach md0.eli
</pre>
Agora é possível montar essa imagem em outro sistema somente com a senha.
<pre># mdconfig -at vnode -f /cryptedfile
# geli attach /dev/md0
# mount /dev/md0.eli /mnt
</pre>
</div>
<h2 id="osxcrypt">imagem de disco criptografa do OS X</h2>
Não sabe somente por linha de comando. Veja <a href="https://wiki.thayer.dartmouth.edu/display/computing/Creating+a+Mac+OS+X+Encrypted+Disk+Image">Imagem de disco criptografada do OS X</a><span class="fn">https://wiki.thayer.dartmouth.edu/display/computing/Creating+a+Mac+OS+X+Encrypted+Disk+Image</span> e <a href="http://support.apple.com/kb/ht1578">Apple support</a><span class="fn">http://support.apple.com/kb/ht1578</span>

<div id="certs"><h1><a>Certificado SSL</a></h1>
Chamados de certificados SSL/TLS são certificados de chaves públicas criptografadas e são compostas de uma chave pública e uma privada. O certificados são utilizados para autenticar os endpoints e criptografar os dados. Elas são utilizadas por exemplo em um servidor server (https) ou servidor de e-mail (imaps).
<h2>Procedimento</h2>
<ul>
<li>Precisamos de uma autoridade de certificado (certificate authority) para asinar nosso certificado. Esse passo geralmente é fornecido por um vendedor como a Thawte, a Verisign, etc., no entanto nós mesmos podemos também criar o nosso.</li>
<li>Cria uma solicitação de assinatura de certificado. Essa solicitação é como um certificado não assinado (a parte pública) e já contem todas as informações necessárias. A solicitação de certificação normalmente é enviada para o fornecedor da autoridade para a assinatura. Esse passo também cria a chave privada na maquina local.</li>
<li>assine o certificado com a autoridade do certificado.</li>
<li>Se necessário junta o certificado e a chave em um único arquivo para ser utilizado pela aplicação (servidor web, servidor de mail etc.).</li>
</ul>

<h2>Configurar OpenSSL</h2>
Nós usamos /usr/local/certs como diretório para esse exemplo; verifique ou edite /etc/ssl/openssl.cnf de acordo com as suas configurações, assim você sabe aonde os arquivos serão criados. Aqui estão as partes do openssl.cnf:
<pre>[ CA_default ]
dir             = /usr/local/certs/CA       <span class="cmt"># Aonde tudo é mantido</span>
certs           = $dir/certs                <span class="cmt"># Aonde os certificados emitidos são mantidos</span>
crl_dir         = $dir/crl                  <span class="cmt"># Aonde os crl emitidos são mantidos</span>
database        = $dir/index.txt            <span class="cmt"># arquivos index database (base de dados).</span>
</pre>
Certifique-se de que os diretórios existem ou crie-os
<pre># mkdir -p /usr/local/certs/CA
# cd /usr/local/certs/CA
# mkdir certs crl newcerts private
# echo "01" &gt; serial                        <span class="cmt"># Somente se o serial não existe</span>
# touch index.txt
</pre>

Se você pretende obter um certificado de assinado vindo de um fornecedor, você só precisa uma solicitação de assinatura de certificado (certificate signing request) (CSR). Esse CSR será então assinado pelo fornecedor (vendor) por um tempo limitado (ex. 1 ano).
<h2 id="createca">Criar uma autoridade de certificado</h2>

Se você não tem uma autoridade de certificado de um  fornecedor, Você terá que criar uma própria. Esse passo não é necessário se alguém pretendia utilizar um fornecedor para assinar a solicitação. Para gerar uma autoridade de certificado (certificate authority) (CA):
<pre># openssl req -new -x509 -days 730 -config /etc/ssl/openssl.cnf \
-keyout CA/private/cakey.pem -out CA/cacert.pem
</pre>

<h2 id="createreq">Gerar uma solicitação de assinatura de certificado</h2>
Para gerar um novo certificado (para servidor de mensagens ou servidor web por exemplo), primeiro gere um certificadoo de solicitação com sua chave privada. Se sua aplicação não suporta chave privada criptografada(por exemplo UW-IMAP does not), então desabilite a criptografia com <code>-nodes</code>.
<pre># openssl req -new -keyout newkey.pem -out newreq.pem \
-config /etc/ssl/openssl.cnf
# openssl req -nodes -new -keyout newkey.pem -out newreq.pem \
-config /etc/ssl/openssl.cnf                <span class="cmt"># Sem criptografia para a chave</span>
</pre>
Guarde essa CSR gerada (<code>newreq.pem</code>) desde que ela pode ser assinada novamente na proxima vez que for renovar a página, a assinatura onlt limitará a validide do certificade. Esse processo também gerou a chave privada <code>newkey.pem</code>.

<h2 id="signcert">Assinar o certificado</h2>
A solicitação de certificado tem que ser assinado pela CA para ser validada, esse passo é normalmente feito pelo fornecedor. <i>Nota: substitua "servername" pelo nome do seu servidor nos próximos comandos</i>.
<pre># cat newreq.pem newkey.pem &gt; new.pem
# openssl ca -policy policy_anything -out servernamecert.pem \
-config /etc/ssl/openssl.cnf -infiles new.pem
# mv newkey.pem servernamekey.pem
</pre>
Agora servernamekey.pem é a chave privada e servernamecert.pem é o certificate servidor.

<h2>Gerar certificado unido (united certificate)</h2>
O servidor IMAP que ter ambos (chave privada e certificado do servidor) no mesmo arquivo. De mmodo geral, Isso também é mais fácil de manusear, mas o arquivo deve ser mantido seguro!. O Apache também pode lidar com isso bem. Gere um arquivo servername.pem contendo o certificado e a chave.
<ul>
  <li>Abra a chave privada (servernamekey.pem) com um editor de texto e copie a chave privada para dentro do arquivo "servername.pem".</li>
  <li>Faça o mesmo com o certificado do servidor (servernamecert.pem).</li>
</ul>
O final do arquivo servername.pem deve parecer com isso:<br /><br />
<pre>-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDutWy+o/XZ/[...]qK5LqQgT3c9dU6fcR+WuSs6aejdEDDqBRQ
-----END RSA PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
MIIERzCCA7CgAwIBAgIBBDANB[...]iG9w0BAQQFADCBxTELMAkGA1UEBhMCREUx
-----END CERTIFICATE-----
</pre>
O que temos agora no diretório /usr/local/certs/:
<ul style="list-style-type: none;">
  <li>CA/private/cakey.pem <i>(CA server private key)</i></li>
  <li>CA/cacert.pem <i>(CA server public key)</i></li>
  <li>certs/servernamekey.pem <i>(server private key)</i></li>
  <li>certs/servernamecert.pem <i>(server signed certificate)</i></li>
  <li>certs/servername.pem <i>(server certificate with private key)</i></li>
</ul>
Guarde a chave privada em lugar seguro!

<h2 id="viewcert">Visualizar informações do certificado</h2>
Para visualizar as informações do certificado simplesmente faça:
<pre># openssl x509 -text -in servernamecert.pem      <span class="cmt"># Visualiza a info do certificado</span>
# openssl req -noout -text -in server.csr        <span class="cmt"># Visualiza a info da solicitação</span>
# openssl s_client -connect cb.vu:443            <span class="cmt"># Verifica um certificado do servidor web</span>
</pre>
</div>


<div id="cvs"><h1><a>CVS</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#cvssetup">Configuração do servidor</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#cvstest">teste do CVS</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#cvsssh">tunelamento do SSH</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#cvsusage">uso do CVS</a></p>
<h2 id="cvssetup">Configuração do servidor</h2>
<h3>Iniciar o CVS</h3>
Decida aonde o repositórop principal will permanecer e gerar uma cvs root. Por exemplo /usr/local/cvs (como root):
<pre># mkdir -p /usr/local/cvs
# setenv CVSROOT /usr/local/cvs      <span class="cmt"># Define o CVSROOT para o novo local (local)</span>
# cvs init                           <span class="cmt"># Gera todos os arquivos internos de configuração do CVS</span>
# cd /root
# cvs checkout CVSROOT               <span class="cmt"># verifica os arquivos de configuração para modificá-los</span>
# cd CVSROOT
edit config ( fine as it is)
# cvs commit config
cat &gt;&gt; writers                       <span class="cmt"># Gera um arquivo writers (também o readers opcionalmente)</span>
colin
^D                                   <span class="cmt"># Utiliza [Control][D] para sair da edição</span>
# cvs add writers                    <span class="cmt"># Adiciona o arquivo writers dentro do repositório</span>
# cvs edit checkoutlist
# cat &gt;&gt; checkoutlist
writers
^D                                   <span class="cmt"># Utiliza [Control][D] para sair da edição</span>
# cvs commit                         <span class="cmt"># Envia todas as alterações de configuração</span>
</pre>
Adiciona um arquivo <strong>readers</strong> se você quiser diferenciar permições de leitura e escrita (read and write). <i>Nota:</i> Não edite (nunca) os arquivos diretamente no cvs principal, mas verifique o arquivo, modifique-o e verifique. Fizemos isso com o arquivo <strong>writers</strong> para definir o acesso a escrita.<br />
há três modos populares de acessar o CVS nesse ponto. Os dois primeiros não necessitam de grandes configurações. Veja os exemplos em <a href="http://cb.vu/unixtoolbox.xhtml#cvsroot">CVSROOT</a> abaixo para como utilizá-los:

<ul>
  <li>Acesso local direto ao file system. O(s) usuário(s) precisa(m) premissão ao arquivo o suficiente para acessar o CS directamente e não há mais autenticação em adição ao login do OS. No entando isso só é útil se o repositório for local.</li>
  <li>Acesso remoto com o ssh e com o protocolo ext (ext protocol). Qualquer uso de uma conta com shell ssh e permissões de leitura e escrita (read/write) no servidor CVS podem acessar o CVS diretamente com o ext no ssh sem qualquer tunel adicional. Não há processo no servidor sendo executado no CVS para ele que funcione. O login ssh faz a autenticação de login.</li>
  <li>Acesso remoto com o pserver (porta padrão: 2401/tcp). Esse é o uso preferido por grande base de usuário desde que os ususários são autenticados pelo CVS pserver com uma base de dados de senha dedicada, logo não há necessidade para contas de usuários local. Essa configuração é exeplicada abaixo.</li>
</ul>

<h3>Configuração de rede com o inetd</h3>
O CVS pode ser executado localmente somente se um acesso a rede não for necessário. Para um acesso remoto, a daemon inetd pode iniciar o pserver com o seguinte linha em /etc/inetd.conf (/etc/xinetd.d/cvs no SuSE):
<pre>cvspserver	stream  tcp  nowait  cvs  /usr/bin/cvs	cvs \
--allow-root=/usr/local/cvs pserver
</pre>
Não é uma boa ideia bloquear a porta do port da Internet com o firewall e utilizar um túnel ssh para acessar o rempositório remotamente.

<h3>Separar a autenticação</h3>
É possível ter usuários cvs que não são parte do OS (sem usuários local). Na verdade isso é provavelmente requerido também do ponto de vista da segurança. Simplesmente adicione um arquivo nomeado <strong>passwd</strong> (no diretório CVSROOT) contendo o login de usuário e senha no formato criptografado. Isso pode ser feito com a ferramenta htpasswd do apache (apache htpasswd tool).<br />
<i>Nota:</i> Esse arquivo passwd é o único arquivo que deve ser editedo directamente no diretório CVSROOT. Também não será verificado. Mais informações com o htpasswd --help
<pre># htpasswd -cb passwd user1 password1  <span class="cmt"># -c gera o arquivo file</span>
# htpasswd -b passwd user2 password2
</pre>

Agora adicione <code>:cvs</code> no final de cada linha para dizer ao servidor cvs que altere o usuário para cvs (ou seja o que for que o ser servidor cvs estiver executando). Parece com isso:
<pre># cat passwd
user1:xsFjhU22u8Fuo:cvs
user2:vnefJOsnnvToM:cvs
</pre>

<h2 id="cvstest">Testá-lo</h2>
Teste o login como usuário normal (por exemplo)
<pre># cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs login
Logging in to :pserver:colin@192.168.50.254:2401/usr/local/cvs
CVS password:

</pre>

<h3 id="cvsroot">Variavel CVSROOT</h3>
Essa é uma varável de ambiente utilizada para especificar o local do repositório que estamos realizando as operações. Para uso local, Pode ser definido apenas para o diretório do repositório. Para uso na rede, o protocolo de transporte deve ser especificado. Defina a variável CVSROOT com o <code>setenv CVSROOT string</code> em um shell csh, tcsh shell, ou com o <code>export CVSROOT=string</code> em um shell sh, bash.
<pre># setenv CVSROOT :pserver:&lt;username&gt;@&lt;host&gt;:/cvsdirectory
<i><span class="cmt">Por exemplo:</span></i>
# setenv CVSROOT /usr/local/cvs                               <span class="cmt"># Utilizado localmente (somente)</span>
# setenv CVSROOT :local:/usr/local/cvs                        <span class="cmt"># O mesmo que acima</span>
# setenv CVSROOT :ext:user@cvsserver:/usr/local/cvs           <span class="cmt"># Acesso direto com o SSH</span>
# setenv CVS_RSH ssh                                          <span class="cmt"># para o acesso ext</span>
# setenv CVSROOT :pserver:user@cvsserver.254:/usr/local/cvs   <span class="cmt"># rede com o pserver</span>
</pre>
Quando o login for bem sucedido, a pessoa pode importar um novo projeto para dentro do repositório:
<strong>cd dentro</strong> do diretório root do seu projeto
<pre>cvs import &lt;module name&gt; &lt;vendor tag&gt; &lt;initial tag&gt;
cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs import MyProject MyCompany START
</pre>

Aonde MyProject é o nome do novo projeto no repositório (utilizado mais tarde para verificar). Cvs importará o conteudo do diretório atual  para dentro do novo projeto.<br /><br />
Verificar:
<pre># cvs -d :pserver:colin@192.168.50.254:/usr/local/cvs checkout MyProject
<i><span class="cmt">ou</span></i>
# setenv CVSROOT :pserver:colin@192.168.50.254:/usr/local/cvs
# cvs checkout MyProject
</pre>

<h2 id="cvsssh">Tunelamento SSH para CVS</h2>
Precisamos de 2 shells para isso. No primeiro shell conectamos o servidor cvs com o ssh e direcionamos (port-forward) a conexão cvs. No segundo shell utilizamos o cvs normalmente como se estivesse sendo executado localmente.
<br />
no shell 1:
<pre># ssh -L2401:localhost:2401 colin@cvs_server   <span class="cmt"># Conecte diretamente ao servidor CVS. Ou:</span>
# ssh -L2401:cvs_server:2401 colin@gateway     <span class="cmt"># Utilize um gateway para alcançar o CVS</span></pre>
no shell 2:
<pre># setenv CVSROOT :pserver:colin@localhost:/usr/local/cvs
# cvs login
Logging in to :pserver:colin@localhost:2401/usr/local/cvs
CVS password:
# cvs checkout MyProject/src
</pre>
<h2 id="cvsusage">Comandos CVS e uso</h2>
<h3>Import</h3>
O comando import é utilizado para adicionar um diretório inteiro, ele deve ser executado dentro do diretório para ser importado. Digamos que ao diretório /devel/ contem todos os arquivos e subdiretórios a serem importados. O nome do diretório no CVS (o módulo) será chamado "myapp".
<pre># cvs import [options] directory-name vendor-tag release-tag
# cd /devel                          <span class="cmt"># Deve estar dentro do projeto para importá-lo</span>
# cvs import myapp Company R1_0      <span class="cmt"># libera tag, pode ser qualquer coisa em uma palavra</span>
</pre>
Depois de algum tempo um novo diretório "/devel/tools/" foi adicionado e precisa ser importado também.
<pre># cd /devel/tools
# cvs import myapp/tools Company R1_0
</pre>
<h3>Verificar adição da atualização</h3>
<pre># cvs co myapp/tools                 <span class="cmt"># Verificará somente as ferramentas do diretório</span>
# cvs co -r R1_1 myapp               <span class="cmt"># Verifica myapp no release R1_1 (está colado)</span>
# cvs -q -d update -P                <span class="cmt"># Uma atualização típica do CVS</span>
# cvs update -A                      <span class="cmt"># Redefine qualquer estiqueta colada (sticky tag) (ou data, opção)</span>
# cvs add newfile                    <span class="cmt"># Adiciona um novo arquivo</span>
# cvs add -kb newfile                <span class="cmt"># Adiciona um novo arquivo binário</span>
# cvs commit file1 file2             <span class="cmt"># Envia somente os dois arquivos</span>
# cvs commit -m "message"            <span class="cmt"># Envia todas as alterações feitas com uma mensagem</span>
</pre>

<h3>Gerar um patch</h3>
É melhor gerar e aplicar um a partir do diretório de desenvolvimento de trabalho relacionado ao projeto, ou de dentro do diretório fonte.
<pre># cd /devel/project
# diff -Naur olddir newdir &gt; patchfile <span class="cmt"># Gera um patch a partir de um diretório ou de um arquivo</span>
# diff -Naur oldfile newfile &gt; patchfile
</pre>
<h3>Aplicar um patch</h3>
As vezes é necessário espanar um nível de diretório do patch, dependendo de como ele foi gerado. Em caso de dificuldades, simplesmente nas primeiras linhas do patch e tente -p0, -p1 ou -p2.
<pre># cd /devel/project
# patch --dry-run -p0 &lt; patchfile    <span class="cmt"># Teste o caminho (path) sem aplicá-lo</span>
# patch -p0 &lt; patchfile
# patch -p1 &lt; patchfile              <span class="cmt"># espana o primeiro nível do path</span>
</pre>
</div>

<div id="svn"><h1><a>SVN</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#svnsetup">Configuração do servidorp</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#svnssh">SVN+SSH</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#svnhttp">SVN no http</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#svnusage">Uso do SVN</a></p>
<a href="http://subversion.tigris.org/">Subversion (SVN)</a><span class="fn">http://subversion.tigris.org/</span> é um sistema de controle de versão projetado para ser o sucessor do CVS (Concurrent Versions System). O conceito é similar ao CVS, mas muitas deficiências foram melhoradas. Veja tambem o <a href="http://svnbook.red-bean.com/en/1.4/">SVN book</a><span class="fn">http://svnbook.red-bean.com/en/1.4/</span>.
<h2 id="svnsetup">configuração do servidor setup</h2>
A iniciação do repositório é bastante simples (aqui por exemplo <code>/home/svn/</code> deve existe):
<pre># svnadmin create --fs-type fsfs /home/svn/project1</pre>
Agora o acesso ao repositório torna-se possível com:
<ul>
  <li><code>file://</code> Acesso direto ao sistema de arquivo com o cliente svn. Isso requer permissões locais no sistema de arquivo.</li>
  <li><code>svn://</code> ou <code>svn+ssh://</code> acesso remoto com o servidor svnserve (também pelo SSH). Isso requer permissões locais no sistema de arquivo (porta padrão: 2690/tcp).</li>
  <li><code>http://</code> Acesso remoto com o webdav utilizando o apache. usuários locais não são necessário para esse método.</li>
</ul>
Utilizando o sistema de arquivo local, não é possível importar e então verificar um projeto existente. diferente do CVS, não é necessário dar cd dentro do diretório do projeto, simplesmente dê o path completo:
<pre># svn import /project1/ file:///home/svn/project1/trunk -m 'Initial import'
# svn checkout file:///home/svn/project1
</pre>
O novo diretório "trunk" é somente uma convenção, isso não exigido.
<h3 id="svnssh">Acesso remoto com ssh</h3>
Nenhuma configuração especial é exigida para acessar o repositório via ssh, simplesmente sustitua <code>file://</code> com <code>svn+ssh/hostname</code>. Por exemplo:
<pre># svn checkout svn+ssh://hostname/home/svn/project1</pre>
Assim com o acesso ao arquivo local, todo usuário precisa de um acesso ssh para o servidor (com uma conta local) e também acesso a leitura/escrita. Esse metodo pode seradequado para um grupo pequeno. Tudos os usuáriors poderia pertencer a um grupo de subversão que pertence ao repositório, por exemplo:
<pre># groupadd subversion
# groupmod -A user1 subversion
# chown -R root:subversion /home/svn
# chmod -R 770 /home/svn
</pre>
<h3 id="svnhttp">Acesso remoto com o http (apache)</h3>
Acesso remoto pelo http (https) é a única boa solução para um grupo de usuários grande. Esse método utiliza a autenticação apache, não as contas local. Essa é uma configuração típica do apache, porém pequena:
<pre>LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so   <span class="cmt"> # Somente para controle de acesso</span>
</pre><pre style="page-break-inside:avoid;">&lt;Location /svn&gt;
  DAV svn
  <span class="cmt"># qualquer URL "/svn/foo" será mapeado para um repositório /home/svn/foo</span>
  SVNParentPath /home/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthzSVNAccessFile /etc/apache2/svn.acl
  AuthUserFile /etc/apache2/svn-passwd
  Require valid-user
&lt;/Location&gt;
</pre>
O servidor apache precisa de total acesso ao repositório:
<pre># chown -R www:www /home/svn</pre>
Criar um usuário com o htpasswd2:
<pre># htpasswd -c /etc/svn-passwd user1 <span class="cmt"> # -c cria o arquivo</span></pre>
<h4>Exemplo de controle de acesso svn.acl</h4>
<pre><span class="cmt"># Acesso padrão é somente leitura. "* =" seria sem acesso padrão</span>
[/]
* = r
[groups]
project1-developers = joe, jack, jane
<span class="cmt"># Da acesso de escrita aos desenvolvedore</span>
[project1:]
@project1-developers = rw
</pre>

<h2 id="svnusage">Comandos SVN e uso</h2>
Veja também o <a rel="nofollow" href="http://www.cs.put.poznan.pl/csobaniec/Papers/svn-refcard.pdf">Subversion Quick Reference Card</a><span class="fn">http://www.cs.put.poznan.pl/csobaniec/Papers/svn-refcard.pdf</span>. <a href="http://tortoisesvn.tigris.org/">Tortoise SVN</a><span class="fn">http://tortoisesvn.tigris.org</span> é uma interface de janela agradavel.
<h3 id="svnimport">Importar</h3>
um novo projeto, que é um diretório com alguns arquivos, é importado para dentro do repositório com o comando <code>import</code>. Import também é utilizado para adicionar um diretório com seu conteúdo para um projeto existente.
<pre># svn help import                               <span class="cmt"> # obtém ajuda para qualquer comando</span>
<span class="cmt">    # Adiciona um novo diretório (com conteudo) para dentro do diretório src no project1</span>
# svn import /project1/newdir http://host.url/svn/project1/trunk/src -m 'add newdir'
</pre>
<h3 id="svntypical">Typical SVN commands</h3>
<pre># svn co http://host.url/svn/project1/trunk     <span class="cmt"> # Verifica a versão mais recente</span>
<span class="cmt">    # Etiquetas (Tags) e ramos (branches) são gerados ao copiar</span>
# svn mkdir http://host.url/svn/project1/tags/  <span class="cmt"> # Cria o diretório tags</span>
# svn copy -m "Tag rc1 rel." http://host.url/svn/project1/trunk \
                             http://host.url/svn/project1/tags/1.0rc1
# svn status [--verbose]                        <span class="cmt"> # Verifica status de arquivos dentro do diretório de trabalho</span>
# svn add src/file.h src/file.cpp               <span class="cmt"> # Adiciona dois arquivos</span>
# svn commit -m 'Added new class file'          <span class="cmt"> # Gera as alterações com uma mensagem</span>
# svn ls http://host.url/svn/project1/tags/     <span class="cmt"> # Lista todas as tags</span>
# svn move foo.c bar.c                          <span class="cmt"> # Move (renomeia) arquivos</span>
# svn delete some_old_file                      <span class="cmt"> # Exclui arquivos</span>
</pre>

</div>

<div id="other"><h1><a>Comandos uteis</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#less">less</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#vi">vi</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#mail">mail</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#tar">tar</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#zip">zip</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#dd">dd</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#screen">screen</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#find">find</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#misccmd">Miscellaneous</a></p>
<h2 id="less">less</h2>
O comando <code>less</code> exibe um domcumento de texto no console. Ele é presente em muitas instalações.
<pre># less unixtoolbox.xhtml</pre>
Alguns comandos importantes são (^N representa o [control]-[N]):
<ul style="list-style-type: none;">
  <li><strong>h  H</strong>       boa ajuda na exibição</li>
  <li><strong>f  ^F  ^V  SPAÇO</strong>       Avança uma janela (ou N de linhas).</li>
  <li><strong>b  ^B  ESC-v</strong>       Volta uma janela (ou N de linhas).</li>
  <li><strong>F</strong>       Avança eternamente; como o "tail -f".</li>
  <li><strong>/parametro</strong>       Procura por (N-th) linha marcada.</li>
  <li><strong>?parametro</strong>       Procura por (N-th) linha marcada.</li>
  <li><strong>n</strong>       Repete busca anterior (ou N-th localização).</li>
  <li><strong>N</strong>       Repete busca anterior em direção reversa.</li>
  <li><strong>q</strong>       sai</li>
</ul>


<h2 id="vi">vi</h2>
Vi está presente em QUALQUER instalação Linux/Unix (não no gentoo?) e é logo útil saber alguns comandos básicos. Há dois modos: modo comando e modo inserção. O modo de comandos é acessado com <strong>[ESC]</strong>, o modo de inserção com o <strong>i</strong>. Use <code>: help</code> se estiver perdido.<br />
Os editores <code>nano</code> e <code>pico</code> estão geralmente disponíveis tambem e são mais faceis (IMHO) de usar.
<h3>Sair (Quit)</h3>
<ul style="list-style-type: none;">
  <li><strong>:w</strong> newfilename       salva o arquivo em com o nome de newfilename</li>
  <li><strong>:wq or :x</strong>       salva e sai</li>
  <li><strong>:q!</strong>       sai sem salvar</li>
</ul>
<h3>Buscar e mover</h3>
<ul style="list-style-type: none;">
  <li><strong>/string</strong>       Busca por string para frente</li>
  <li><strong>?string</strong>       Volta por string para tras</li>
  <li><strong>n</strong>       Buspa pela próxima instancia de string</li>
  <li><strong>N</strong>       Busca por instacia de instring anterior</li>
  <li><strong>{</strong>       Move um paragrafo para tras</li>
  <li><strong>}</strong>       Move um paragrafo para frente</li>
  <li><strong>1G</strong>       Move para a primeira linha do arquivo</li>
  <li><strong>nG</strong>       Move para o n th de linha do arquivo</li>
  <li><strong>G</strong>       Move para a ultima ultima linha do arquivo</li>
  <li><strong>:%s/OLD/NEW/g</strong>       Busca e substitui toda a ocorrencia</li>
</ul>
<h3>Excluir, copiare colar text</h3>
<ul style="list-style-type: none;">
  <li><strong>dd (dw)</strong>       Corta linha corrente (palavra)</li>
  <li><strong>D</strong>       Cut to the end of the line</li>
  <li><strong>x</strong>       Delete (cut) character</li>
  <li><strong>yy (yw)</strong>       Copy line (word) after cursor</li>
  <li><strong>P</strong>       Paste after cursor</li>
  <li><strong>u</strong>       Desfaz a ultima modificação</li>
  <li><strong>U</strong>       Desfaz todas as alterações até a linha atual</li>
</ul>

<h2 id="mail">mail</h2>
O comando <code>mail</code> é uma aplicação básica para ler e enviar email, é normalmente instalado. para enviar um email simplesmente digite "mail user@domain". A primeira linha é o assunto, depois o conteúdo da mensagem. Termine e envie o email com um único ponto (.) em uma nova linha. Exemplo:
<pre># mail c@cb.vu
Subject: Seu texto está cheio de erros de digitação
"Por um tempo, nada aconteceu. Depois de alguns segundos ou mais, 
nada continua acontecendo."
.
EOT
#
</pre>
Também funciona com um cano (pipe):
<pre># echo "Esse é o corpo da mensagem" | mail c@cb.vu</pre>
Essa é também uma forma simples de testar o servidor de e-mail.

<h2 id="tar">tar</h2>
O comando <code>tar</code> (tape archive) gera e extrai arquivos e diretórios armazenados. O arquivo .tar descompactado, um arquivo compactado tem a extenção .tgz ou .tar.gz (zip) ou .tar.bz (bzip2). Não utilize caminho absoluto quando gerar um arquivo, você provavelmente quer desempacotá-lo em algum outro luar. Alguns comandos são:
<h3>Gerar</h3>
<pre># cd /
# tar -cf home.tar home/        <span class="cmt"># arquiva o diretório /home completo (c para criar)</span>
# tar -czf home.tgz home/       <span class="cmt"># o mesmo com compressão zip</span>
# tar -cjf home.tbz home/       <span class="cmt"># o mesmo com compressão bzip2</span>
</pre>
inclue somente um (ou dois) diretórios a partir de uma arvore, mas mantem a estrutura relativa. Por exemplo, arquivar /usr/local/etc e /usr/local/www e o primeiro diretório no arquivo deve ser local/.
<pre># tar -C /usr -czf local.tgz local/etc local/www
# tar -C /usr -xzf local.tgz    <span class="cmt"># Para desempacotar (untar) o diretório local dentro de /usr</span>
# cd /usr; tar -xzf local.tgz   <span class="cmt"># é o mesmo que acima</span>
</pre>
<h3>Extrair</h3>
<pre># tar -tzf home.tgz             <span class="cmt"># Olha dentro do arquivo sem extraiir (lista)</span>
# tar -xf home.tar              <span class="cmt"># extrai o arquivo aqui (x para extrair)</span>
# tar -xzf home.tgz             <span class="cmt"># o mesmo que da compressão zip (-xjf para a compressão bzip2)</span>
                                <span class="cmt"># remove caminho guias gallery2 e extrai para dentro de gallery</span>
# tar --strip-components 1 -zxvf gallery2.tgz -C gallery/ 
# tar -xjf home.tbz home/colin/file.txt    <span class="cmt"># Restaura um único arquivo</span>
# tar -xOf home.tbz home/colin/file.txt    <span class="cmt"># Imprime o arquivo na saída (stdout) (sem extração)</span>
</pre>
<h3>Mais avançado</h3>
<pre># tar c dir/ | gzip | ssh user@remote 'dd of=dir.tgz' <span class="cmt"># arquiva o dir/ e armazena remotamente.</span>
# tar cvf - `find . -print` &gt; backup.tar              <span class="cmt"># arquiva o diretório atual.</span>
# tar -cf - -C /etc . | tar xpf - -C /backup/etc      <span class="cmt"># Copia diretórios</span>
# tar -cf - -C /etc . | ssh user@remote tar xpf - -C /backup/etc      <span class="cmt"># Copia remota.</span>
# tar -czf home.tgz --exclude '*.o' --exclude 'tmp/' home/
</pre>
<h2 id="zip">zip/unzip</h2>
Arquivos zip pode ser faceis de compartilhar com o Windows.
<pre># zip -r fileName.zip /path/to/dir                    <span class="cmt"># zipa o diretório para dentro do arquivo fileName.zip</span>
# unzip fileName.zip                                  <span class="cmt"># descompacta o arquivo zip</span>
# unzip -l fileName.zip                               <span class="cmt"># lista arquivos dentro do arquivo</span>
# unzip -c fileName.zip fileinside.txt                <span class="cmt"># imprime um arquivo na saída (sem extração)</span>
# unzip fileName.zip fileinside.txt                   <span class="cmt"># extrai somente um arquivo</span>
</pre>

<h2 id="dd">dd</h2>
O programa <code>dd</code> (disk dump ou destroy disk ou veja <a href="http://roesler-ac.de/wolfram/acro/credits.htm"> (the meaning of dd</a>) é utilizado para copiar partições e discos e para outros truques de cópias. Uso típico:
<pre># dd if=&lt;source&gt; of=&lt;target&gt; bs=&lt;byte size&gt; conv=&lt;conversion&gt;
# kill -INFO PID                                      <span class="cmt"># Visualiza p processo do dd (FreeBSD, OSX)</span>
</pre>
Opções importantes:
<ul style="list-style-type: none;">
  <li><code>notrunc</code>       não trunca a saída do arquivo, todos os zeros serão escrtidos como zeros.</li>
  <li><code>noerror</code>       continua depois da leitura de erros (ex. bad blocks)</li>
  <li><code>sync</code>       Enche todo bloco de entrada com Nulls para ibs-size</li>
</ul>
O tamanho de byte padrão é de 512 (um bloco). O MBR, aonde a tabela de partição fica localizada, fica no primeiro bloco, os primeiros 63 blocos de um disco ficam vazios. Tamanos maiores de byte são mais raídos para copiar mas requer também mais memória.
<h3>Backup e restaurção</h3>
<pre># dd if=/dev/hda of=/dev/hdc bs=16065b                <span class="cmt"># Copia de disco para disco (do mesmo tamanho)</span>
# dd if=/dev/sda7 of=/home/root.img bs=4096 conv=notrunc,noerror <span class="cmt"># Realiza backup do /</span>
# dd if=/home/root.img of=/dev/sda7 bs=4096 conv=notrunc,noerror <span class="cmt"># Restaura o /</span>
# dd bs=1M if=/dev/ad4s3e | gzip -c &gt; ad4s3e.gz                  <span class="cmt"># Zipa o backup</span>
# gunzip -dc ad4s3e.gz | dd of=/dev/ad0s3e bs=1M                 <span class="cmt"># Restaura o zip</span>
# dd bs=1M if=/dev/ad4s3e | gzip | ssh eedcoba@fry 'dd of=ad4s3e.gz' <span class="cmt"># também remoto</span>
# gunzip -dc ad4s3e.gz | ssh eedcoba@host 'dd of=/dev/ad0s3e bs=1M'
# dd if=/dev/ad0 of=/dev/ad2 skip=1 seek=1 bs=4k conv=noerror    <span class="cmt"># Pula o MBR</span>
    <span class="cmt"># Isso é necessário se o destino (ad2) for menor.</span>
# dd if=/vm/FreeBSD-8.2-RELEASE-amd64-memstick.img of=/dev/disk1 bs=10240 conv=sync
    <span class="cmt"># Copia a imagem do FreeBSD para o pendrive (USB memory stick)</span>
</pre>

<h3>Recuperar</h3>
O comando <code>dd</code> lerá <i>cada bloco</i> da partiçã. Em caso de problemas é melhor usar a opção <code>conv=sync,noerror</code> então o dd pulará o bad block e escreverá zeros no destino. Concequentemente é importante definir o tamanho do bloco igual ou menor do que o tamanho dos blocos do disco. o tomanho de 1k parece seguro, defina-o com <code>bs=1k</code>. Se um disco tem setores ruins (bad sectors) e o dado deve ser restituído a partir de uma partição, Gere um arquivo de imagem com o dd, monte a imagem e copie o conteúdo para um novo disco. Com a opção <code>noerror</code>, dd pulará os setores ruins e escreverá zeros ao inves de ocupá-los, assim somente os dados contiddos nos setores ruins serão perdidos.

<pre># dd if=/dev/hda of=/dev/null bs=1m                   <span class="cmt"># verificar se há bad blocks</span>
# dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc | gzip | ssh \ <span class="cmt"># Envia para algum lugar remoto</span>
root@fry 'dd of=hda1.gz bs=1k'
# dd bs=1k if=/dev/hda1 conv=sync,noerror,notrunc of=hda1.img    <span class="cmt"># Armazena dentro de uma imagem</span>
# mount -o loop /hda1.img /mnt                        <span class="cmt"># <a class="xref" href="http://cb.vu/unixtoolbox.xhtml#createimg">Monta a imagem</a></span>
# rsync -ax /mnt/ /newdisk/                           <span class="cmt"># Copia em um novo disco</span>
# dd if=/dev/hda of=/dev/hda                          <span class="cmt"># Atulizar o estado magnético (apagará todo o disco)</span>
  <span class="cmt"># A opção acima é util para atualizar o disco. É perfeitamente seguro, mas deve ser desmontado.</span>
</pre>
<h3>Excluir</h3>
<pre># dd if=/dev/zero of=/dev/hdc                         <span class="cmt"># Exclui (zera) todo o disco</span>
# dd if=/dev/urandom of=/dev/hdc                      <span class="cmt"># Exlcui melhor todo o disco</span>
# kill -USR1 PID                                      <span class="cmt"># Visualiza o progresso do dd (Linux)</span>
# kill -INFO PID                                      <span class="cmt"># Visualiza o progresso do dd (FreeBSD)</span>
</pre>
<h3>MBR truques</h3>
O MBR contem o carregardor de boot (boot loader) e a tabela de partição e é do tamamndo de 512 bytes. Os primeiros 446 são para o carregador de boot, os bytes 446 á 512 são para a tabela de partição.
<pre># dd if=/dev/sda of=/mbr_sda.bak bs=512 count=1       <span class="cmt"># Faz backup de todo o MBR</span>
# dd if=/dev/zero of=/dev/sda bs=512 count=1          <span class="cmt"># Exclui o MBR e a tabela de partições</span>
# dd if=/mbr_sda.bak of=/dev/sda bs=512 count=1       <span class="cmt"># Recupera todo o MBR</span>
# dd if=/mbr_sda.bak of=/dev/sda bs=446 count=1       <span class="cmt"># Recupera somente o carregador de boot</span>
# dd if=/mbr_sda.bak of=/dev/sda bs=1 count=64 skip=446 seek=446 <span class="cmt"># Recupera a tabela de partições</span>
</pre>

<h2 id="screen">screen</h2>
Screen (a must have) tem duas funcionalidades principais:
<ul>
<li>Executa seções de terminais multiplos dentro do mesmo terminal.</li>
<li>Um programa inicial é disaciado do terminal original e pode assim executar em plano de fundo (background). O verdadeiro terminal pode ser fechado e e re-anexado mais tarde.</li>
</ul>
<h3>Exemplo curto de exemplo</h3>
Iniciar a tela com:
<pre># screen</pre>
Dentro da seção da tela nós podemos inicar um programa bem duradouro (como o top).
<pre># top</pre>
Agora separe com o <strong>Ctrl-a Ctrl-d</strong>. Recoloque o terminal com:
<pre># screen -R -D</pre>
Em detalhes, isso significa: Se uma seção estiver sendo executadag, então recoloque. Se necessário separe o faça logout remotamente primeiro. Se não estiver sendo executado, gere-o e netifique ao usuário. Ou:
<pre># screen -x</pre>
Anexe a tela em execução em um modo multi display. O console é assim compartilhado entre outros multiplos usuários. Muito util para a equipe de trabalho/debug!

<h3>Comandos de tela (dentro da tela)</h3>
Todos os comandos de tela iniciam com <strong>Ctrl-a</strong>.
<ul>
  <li><strong>Ctrl-a ?</strong> ajuda e sumário de funções</li>
  <li><strong>Ctrl-a c</strong> gera uma nova janela (terminal)</li>
  <li><strong>Ctrl-a Ctrl-n and Ctrl-a Ctrl-p</strong> mudar para a janela seguinte ou anterior
na lista, por número.</li>
  <li><strong>Ctrl-a Ctrl-N</strong> aonde N é um número de 0 á 9, para mudar para a janela correspondente.</li>
  <li><strong>Ctrl-a "</strong> para obter uma lista navegavel de janelas em execução</li>
  <li><strong>Ctrl-a a</strong> para limpar um missed Ctrl-a perdido </li>
  <li><strong>Ctrl-a Ctrl-d</strong> para disconectar e deixar a sessão que está em execução no plano de fundo (background)</li>
  <li><strong>Ctrl-a x</strong> trava o terminal com uma senha</li>
  <li><strong>Ctrl-a [</strong> entra no modo <strong>scrollback</strong>, sai com <strong>esc</strong>.<br />
  Use <code>echo "defscrollback 5000" &gt; ~/.screenrc</code> para almentar o buffer (o padrão é 100)</li>
  <ul>
    <li><strong>C-u</strong> Rola meia página para cima</li>
    <li><strong>C-b</strong> Rola uma página inteira para cima</li>
    <li><strong>C-d</strong> Rola meia página para baixo</li>
    <li><strong>C-f</strong> Rola uma página inteira para baixo</li>
    <li><strong>/</strong> Busca (a frente)</li>
    <li><strong>?</strong> Busca (para tras)</li>
  </ul>
</ul>
A sessão é terminada quando o programa dentro do termianl em execuçao for fechado e você fizer logout do terminal.

<h2 id="find">Find</h2>
Algumas opções importantes:
<ul style="list-style-type: none;">
  <li><code>-x</code> (on BSD) <code>-xdev</code> (no Linux)       Permanece no mesmo sistam de arquivo (dev em fstab).</li>
  <li><code>-exec cmd {} \;</code>       Executa o comando e substitui {} pelo caminho completo</li>
  <li><code>-iname</code>       Como o -name mas é case insensitive</li>
  <li><code>-ls</code>       Exibe informações a respeito do arquivo (como ls -la)</li>
  <li><code>-size n</code>       n é +-n (k M G T P)</li>
  <li><code>-cmin n</code>       Status de arquivo que foi alterado pela utlima vez em n de minutes atras.</li>
</ul>
<pre># find . -type f ! -perm -444        <span class="cmt"># Encontra arquivos não legiveis por todos</span>
# find . -type d ! -perm -111        <span class="cmt"># Encontra diretórios não acessíveis por todos</span>
# find /home/user/ -cmin 10 -print   <span class="cmt"># Arquivos gerados ou modificados nos ultimos 10 minutos.</span>
# find . -name '*.[ch]' | xargs grep -E 'expr' <span class="cmt"># Busca 'expr' nesse diretório eabaixo.</span>
# find / -name "*.core" | xargs rm   <span class="cmt"># Encontra core dumps e os exclui (também tenta core.*)</span>
# find / -name "*.core" -print -exec rm {} \;  <span class="cmt"># Otra syntax</span>
      <span class="cmt"># Encontra imagens e gera um arquivo, iname não é case sensitive. -r para anexo (append)</span>
# find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;
# find . -type f -name "*.txt" ! -name README.txt -print  <span class="cmt"># Exclui arquivos README.txt</span>
# find /var/ -size +10M -exec ls -lh {} \;     <span class="cmt"># Encontra arquivos grandes &gt; 10 MB</span>
# find /var/ -size +10M -ls           <span class="cmt"># Isso é mais simples</span>
# find . -size +10M -size -50M -print
# find /usr/ports/ -name work -type d -print -exec rm -rf {} \;  <span class="cmt"># Limpa as portas</span>
      <span class="cmt"># Find files with SUID; those file are vulnerable and must be kept secure</span>
# find / -type f -user root -perm -4000 -exec ls -l {} \;
# find flac/ -iname *.flac -print -size +500k -exec /Applications/Fluke.app/Contents/MacOS/Fluke {} \;
                                      <span class="cmt"># Eu utilizo a opção acima para adicionar arquivos flac (formato de audio) ao iTunes no OSX</span>
</pre>
Seja cuidadoso com o xarg ou o exec já que pode ou não honrar quotings e pode retornar resultados errados quando os arquivos ou diretórios conterem espaçoes. Na dúvida, utilize "-print0 | xargs -0" instead of "| xargs". A opção -print0 deve ser a ultima no comando find. Veja esse bom <a href="http://www.hccfl.edu/pollock/Unix/FindCmd.htm">mini tutorial para o find (em inglês)</a><span class="fn">http://www.hccfl.edu/pollock/Unix/FindCmd.htm</span>.
<pre># find . -type f | xargs ls -l       <span class="cmt"># Não funcionará com espaços nos names</span>
# find . -type f -print0 | xargs -0 ls -l  <span class="cmt"># Não funcionará com espaços nos nomes</span>
# find . -type f -exec ls -l '{}' \; <span class="cmt"># Or use quotes '{}' with -exec</span>
</pre>
Duplicar arvore de diretório:
<pre># find . -type d -exec mkdir -p /tmp/new_dest/{} \;</pre>
<h2 id="misccmd">Miscelâneas</h2>
<pre># which comando                      <span class="cmt"># Exibe nome completo do  caminho do comando</span>
# time comando                       <span class="cmt"># Veja quanto tempo p comando leva para  ser executado</span>
# time cat                           <span class="cmt"># Usa o time como o as cronômetro. Ctrl-c para parar</span>
# set | grep $USER                   <span class="cmt"># Lista o ambiente atual</span>
# cal -3                             <span class="cmt"># Exibe um calendário de três meses</span>
# date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]
# date 10022155                      <span class="cmt"># Define data e hora</span>
# whatis grep                        <span class="cmt"># Exibe uma informação curta no comando</span>
# whereis java                       <span class="cmt"># Busca caminho (path) e diretórios padrões paar a palavra</span>
# setenv varname value               <span class="cmt"># Set env. variável varname para o valor (csh/tcsh)</span>
# export varname="value"             <span class="cmt"># set env. variével varname para o valor (sh/ksh/bash)</span>
# pwd                                <span class="cmt"># Imprime diretório de trabalho atual (sigça de Print Working Directory)</span>
# mkdir -p /path/to/dir              <span class="cmt"># sem erro se existir, gera diretórios pai caso necessário (parent dirs)</span>
# mkdir -p project/{bin,src,obj,doc/{html,man,pdf},debug/some/more/dirs}
# rmdir /path/to/dir                 <span class="cmt"># Remove o diretório</span>
# rm -rf /path/to/dir                <span class="cmt"># Remove e diretório e o seu conteúdo (f= força)</span>
# rm -- -badchar.txt                 <span class="cmt"># Remove o arquvo que inicia com um traço (-)</span>
# cp -la /dir1 /dir2                 <span class="cmt"># Arquiva e gera arquivos hard link ao inves de copiá-los</span>
# cp -lpR /dir1 /dir2                <span class="cmt"># O mesmo para o FreeBSD</span>
# cp unixtoolbox.xhtml{,.bak}        <span class="cmt"># Jeito curto de copiar o arquivo com uma nova extenção</span>
# mv /dir1 /dir2                     <span class="cmt"># Renomeia um diretório</span>
# ls -1                              <span class="cmt"># lista um arquivo por linha</span>
# history | tail -50                 <span class="cmt"># Exibe us ultimos 50 comandos utilizados</span>
# cd -                               <span class="cmt"># cd para o diretório anterior ($OLDPWD)</span>
# /bin/ls| grep -v .py | xargs rm -r <span class="cmt"># canalisa (pipe) nomes de arquivos para o rm com o xargs</span>
</pre>
Verificar hashs de arquivo com o openssl. Essa é uma boa alternativa para os comandos <code>md5sum</code> ou <code>sha1sum</code> (FreeBSD utiliza <code>md5</code> e <code>sha1</code>) que não ven sempre instalados por padrão.
<pre># openssl md5 file.tar.gz            <span class="cmt"># Gera um checksum md5 do arquivo</span>
# openssl sha1 file.tar.gz           <span class="cmt"># Gera um checksum sha1 do arquivo</span>
# openssl rmd160 file.tar.gz         <span class="cmt"># Gera um checksum RIPEMD-160 do arquivo</span>
</pre>
</div>

<div id="software"><h1><a>Instalar Software</a></h1>
Normalmente o gerenciados de pacote utiliza a variável do proxy para as requisições http/ftp requests. Dentro de .bashrc:
<pre>export http_proxy=http://proxy_server:3128
export ftp_proxy=http://proxy_server:3128
</pre>
<h2 id="softwarelist">Listar pacotes instalados</h2>
<pre># rpm -qa                            <span class="cmt"># Lista pacotes instalados (RH, SuSE; baseados em RPM)</span>
# dpkg -l                            <span class="cmt"># Debian, Ubuntu</span>
# pkg_info                           <span class="cmt"># FreeBSD lista todos os pacotes intalados</span>
# pkg_info -W smbd                   <span class="cmt"># FreeBSD mostra a qual pacote o smbd pertence</span>
# pkginfo                            <span class="cmt"># Solaris</span>
</pre>
<h2 id="softwareadd">Adicionar/remover software</h2>
Front ends: yast2/yast para o SuSE, redhat-config-packages para o Red Hat.
<pre># rpm -i pkgname.rpm                 <span class="cmt"># installa o pacote (RH, SuSE; baseados em RPM)</span>
# rpm -e pkgname                     <span class="cmt"># Remove pacote</span>
</pre>
<h3>SuSE zypper <a href="http://en.opensuse.org/SDB:Zypper_usage">(veja doc e cheet sheet)</a><span class="fn">http://en.opensuse.org/SDB:Zypper_usage</span></h3>
<pre># zypper refresh                     <span class="cmt"># Atualiza o repositório</span>
# zypper install vim                 <span class="cmt"># Instala o pacote vim</span>
# zypper remove vim                  <span class="cmt"># Remove o pacote vim</span>
# zypper search vim                  <span class="cmt"># Busca por pacontes com vim</span>
# zypper update vim                  <span class="cmt"># Busca por pacotes com vim</span>
</pre>
<h3>Debian</h3>
<pre># apt-get update                     <span class="cmt"># Primeiro, atualize as listas de pacotes</span>
# apt-get install emacs              <span class="cmt"># Instala p pacote emacs</span>
# dpkg --remove emacs                <span class="cmt"># Remove o pacote emacs</span>
# dpkg -S file                       <span class="cmt"># encontra a qual pacote um arquivo pertence</span>
</pre>
<h3>Gentoo</h3>
Gentoo utiliza o emerge como o coração do seu sistema de gerenciamento de pacote "Portage".
<pre># emerge --sync                      <span class="cmt"># Primeiro sincronize a arvore local do portage</span>
# emerge -u packagename              <span class="cmt"># Instale ou atualize um pacote</span>
# emerge -C packagename              <span class="cmt"># Remove o pacote</span>
# revdep-rebuild                     <span class="cmt"># Corrige as dependencias</span>
</pre>
<h3>Solaris</h3>
O caminho do &lt;cdrom&gt; normalmente é <code>/cdrom/cdrom0</code>.
<pre># pkgadd -d &lt;cdrom&gt;/Solaris_9/Product SUNWgtar
# pkgadd -d SUNWgtar                 <span class="cmt"># Adiciona pacote baixado (bunzip2 primeiro)</span>
# pkgrm SUNWgtar                     <span class="cmt"># Remove o pacote</span>
</pre>
<h3>FreeBSD</h3>
<pre># pkg_add -r rsync                   <span class="cmt"># Busca e instala o rsync.</span>
# pkg_delete /var/db/pkg/rsync-xx    <span class="cmt"># Exclui o pacote rsync</span>
</pre>
Define de onde os pacotes são buscados com a variável <code>PACKAGESITE</code>. Por exemplo:
<pre># export PACKAGESITE=ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages/Latest/ 
# ou ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/
</pre>
<h3>FreeBSD <a href="http://www.freebsd.org/handbook/ports.html">ports</a><span class="fn">http://www.freebsd.org/handbook/ports.html</span></h3>
O port tree <code>/usr/ports/</code> é uma coleção de software pronto para compilar e instalar (veja man ports). Os ports são atualizados com o programa <code>portsnap</code>.
<pre># portsnap fetch extract             <span class="cmt"># Gera a arvore quando for executado pela primeira vez</span>
# portsnap fetch update              <span class="cmt"># Atualiza o port tree</span>
# cd /usr/ports/net/rsync/           <span class="cmt"># Seleciona o pacote para instalá-lo</span>
# make install distclean             <span class="cmt"># Instala e limpa (veja também no man ports)</span>
# make package                       <span class="cmt"># Gera um pacote binário desse port</span>
# pkgdb -F                           <span class="cmt"># Corrige a base de dados de registro do pacote</span>
# portsclean -C -DD                  <span class="cmt"># Limpa o workdir e o distdir (parte do portupgrade)</span>
</pre>
<h3 id="macports">OS X <a href="http://guide.macports.org/">MacPorts</a><span class="fn">http://guide.macports.org/</span> (utilize sudo para todos so comandos)</h3>
<pre># port selfupdate                    <span class="cmt"># Atualiza o port tree (seguro)</span>
# port installed                     <span class="cmt"># Lista os ports instalados</span>
# port deps apache2                  <span class="cmt"># Lista as dependencias para esse port</span>
# port search pgrep                  <span class="cmt"># Busca por string</span>
# port install proctools             <span class="cmt"># Instala esse pacote</span>
# port variants ghostscript          <span class="cmt"># Lista variantes desse port</span>
# port -v install ghostscript +no_x11<span class="cmt"># -no_x11 para valor negativo</span>
# port clean --all ghostscript       <span class="cmt"># limpa o workdir of port</span>
# port upgrade ghostscript           <span class="cmt"># Atualiza esse port</span>
# port uninstall ghostscript         <span class="cmt"># Desisntala esse port</span>
# port -f uninstall installed        <span class="cmt"># Desinstala tudo</span>
</pre>
<h2 id="librarypath">Caminho de bibliotéca (Library path)</h2>
Devido as dependencias complexas e o runtime linking, os programas são dificeis de copiar para outro sistema ou distribução. No entando, para programas pequenos com poucas dependências, as bibliotecas que faltam podem ser copiadas. As bibliotecas de tempo de execução (runtime libraries) (e as que faltam) são verificadas com o <code>ldd</code> e gerenciadas com o <code>ldconfig</code>.
<pre># ldd /usr/bin/rsync                 <span class="cmt"># Lista todas as bibliotecas runtime necessárias</span>
# otool -L /usr/bin/rsync            <span class="cmt"># Equivalente ao lss para o OS X</span>
# ldconfig -n /path/to/libs/         <span class="cmt"># Adiciona um path para od diretporios das bibliotecas compartilhadas</span>
# ldconfig -m /path/to/libs/         <span class="cmt"># FreeBSD</span>
# LD_LIBRARY_PATH                    <span class="cmt"># A variável que define a link library path</span>
</pre>
</div>

<div id="convert"><h1><a>Converte Mídia</a></h1>
Algumas vezes alguém precisa simplesmnte converter um arquivo de vídeo, de audio ou documenta para outro formato.
<h2 id="encoding">Text encoding</h2>
Text encoding can get totally wrong, specially when the language requires
special characters like àäç. The command <code>iconv</code> can convert from
one encoding to an other.
<pre># iconv -f &lt;from_encoding&gt; -t &lt;to_encoding&gt; &lt;input_file&gt;
# iconv -f ISO8859-1 -t UTF-8 -o file.input &gt; file_utf8
# iconv -l                           <span class="cmt"># Lista configuraçoes de caracter de coded conhecido</span>
</pre>
Sem a opção -f, iconv utilizará o char-set local, que é normalmente bom
se o documento exibe bem.<br />
Converte filenames de uma condificação para outra (não o conteúdo do arquivo). Funciona também se somente alguns arquivos já forem utf8
<pre># convmv -r -f utf8 --nfd -t utf8 --nfc /dir/* --notest</pre>

<h2 id="newlines">Unix - DOS newlines</h2>
Converte newlines DOS (CR/LF) para Unix (LF) e colta <b>para dentro de um shell Unix</b>. Veja também <code>dos2unix</code> e <code>unix2dos</code> caso tiver.
<pre># sed 's/.$//' dosfile.txt &gt; unixfile.txt                  <span class="cmt"># DOS para UNIX</span>
# awk '{sub(/\r$/,"");print}' dosfile.txt &gt; unixfile.txt   <span class="cmt"># DOS para UNIX</span>
# awk '{sub(/$/,"\r");print}' unixfile.txt &gt; dosfile.txt   <span class="cmt"># UNIX para DOS</span>
</pre>
Converte newlines do Unix para newlines do DOS <b>dentro de um ambiente Windows</b>. Utilize sed ou awk do mingw ou do cygwin.
<pre># sed -n p unixfile.txt &gt; dosfile.txt
# awk 1 unixfile.txt &gt; dosfile.txt   <span class="cmt"># De UNIX para DOS (com o sheel cygwin)</span>
</pre>
Remove newline <code>^M</code> do mac e substiui para unix new line. Para ebter um <code>^M</code> utilize CTL-V e depois CTL-M
<pre># tr '^M' '\n' &lt; macfile.txt
</pre>
<h2>PDF para Jpeg e concatena arquivos PDF</h2>
Converte um documento PDF com o <code>gs</code> (GhostScript) para imagens jpeg (ou png) para cada página. Também bem curto com o <code>convert</code> e o <code>mogrify</code> (do ImageMagick ou GraphicsMagick).
<pre># gs -dBATCH -dNOPAUSE -sDEVICE=jpeg -r150 -dTextAlphaBits=4 -dGraphicsAlphaBits=4 \
 -dMaxStripSize=8192 -sOutputFile=unixtoolbox_%d.jpg unixtoolbox.pdf
# convert unixtoolbox.pdf unixtoolbox-%03d.png
# convert *.jpeg images.pdf          <span class="cmt"># Gera um PDF simple com todas as imagens</span>
# convert image000* -resample 120x120 -compress JPEG -quality 80 images.pdf
# mogrify -format png *.ppm          <span class="cmt"># converte todas as imagens ppm para o formato png</span>
</pre>
Ghostscript pode também concatenar multiplos arquivos pdf dentro de um único. Isso só funciona bem se os arquivos PDF forem "well behaved".
<pre># gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=all.pdf \
file1.pdf file2.pdf ...              <span class="cmt"># No Windows utilize '#' ao inves de '='</span>
</pre>
Extraia imagens do documento pdf utilizando o <code>pdfimages</code> a partir do poppler ou o <a href="http://foolabs.com/xpdf/download.html"><code>xpdf</code></a><span class="fn">http://foolabs.com/xpdf/download.html</span>
<pre># pdfimages document.pdf dst/        <span class="cmt"># extraia todas as imagens e coloque-as dentro do dst</span>
# yum install poppler-utils          <span class="cmt"># instala poppler-utils se necessário. ou:</span>
# apt-get install poppler-utils
</pre>
<h2>Converter vídeo</h2>
Comprime o vídeo da digicam Canon com um codec mpeg4 e o som de baixa qualidade (crappy sound).
<pre># mencoder -o videoout.avi -oac mp3lame -ovc lavc -srate 11025 \
-channels 1 -af-adv force=1 -lameopts preset=medium -lavcopts \
vcodec=msmpeg4v2:vbitrate=600 -mc 0 vidoein.AVI
</pre>
Veja <a href="http://sox.sourceforge.net/">sox</a> para processamento de som.

<h2>Copia um cd de áudio</h2>
o programa <a rel="nofollow" href="http://xiph.org/paranoia/"><code>cdparanoia</code></a><span class="fn">http://xiph.org/paranoia/</span> pode salvar as faixas de  audio (FreeBSD port em audio/cdparanoia/), <code>oggenc</code> pode codificar em formato Ogg Vorbis format, <code>lame</code> converte para mp3.
<pre># cdparanoia -B                      <span class="cmt"># Copia as faixas para arquivos wav no diretório atual</span>
# lame -b 256 in.wav out.mp3         <span class="cmt"># Codifica em mp3 256 kb/s</span>
# for i in *.wav; do lame -b 256 $i `basename $i .wav`.mp3; done
# oggenc in.wav -b 256 out.ogg       <span class="cmt"># Codifica em Ogg Vorbis 256 kb/s</span>
</pre>
</div>

<div id="printing"><h1><a>Impressão</a></h1>
<h2>Imprimir com o lpr</h2>
<pre style="page-break-inside:avoid;"># lpr unixtoolbox.ps                 <span class="cmt"># Imprime na impressora padrão</span>
# export PRINTER=hp4600              <span class="cmt"># Altera a impressora padrão</span>
# lpr -Php4500 #2 unixtoolbox.ps     <span class="cmt"># Utiliza a impressora hp4500 e imprime 2 copias</span>
# lpr -o Duplex=DuplexNoTumble ...   <span class="cmt"># Imprime duplex em long side</span>
# lpr -o PageSize=A4,Duplex=DuplexNoTumble ...
</pre>
<pre># lpq                                <span class="cmt"># Verifica a fila na impressora padrão</span>
# lpq -l -Php4500                    <span class="cmt"># Fila na impressora hp4500 com verbose</span>
# lprm -                             <span class="cmt"># Remove todos os serviços de usuários da impressora padrão</span>
# lprm -Php4500 3186                 <span class="cmt"># Remove o serviço 3186. Encontra serviço nbr c om o lpq</span>
# lpc status                         <span class="cmt"># Lista todas as impressoras disponíveis</span>
# lpc status hp4500                  <span class="cmt"># Verifica se a impressora está online e o comprimento da fila</span>
</pre>
Alguns dispositivos não são posscript e imprimirão lixo quando alimentados com um arquivo pdf file. Isso pode ser resolvido com:
<pre># gs -dSAFER -dNOPAUSE -sDEVICE=deskjet -sOutputFile=\|lpr file.pdf</pre>
Imprime para um arquivo PDF mesmo se a aplicação não a suporta. Utilize <code>gs</code> no comando print command ao inves de <code>lpr</code>.
<pre># gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=/path/file.pdf</pre>
</div>

<div id="databases"><h1><a>Databases</a></h1>
<h2 id="pgsql">PostgreSQL</h2>
<h3>Alterar senha do root ou de um usuário (ou username)</h3>
<pre># psql -d template1 -U pgsql
&gt; alter user pgsql with password 'pgsql_password';  <span class="cmt"># Utilize username ao inves de "pgsql"</span>
</pre>
<h3>Cria usuário e database</h3>
Os comandos <code>createuser</code>, <code>dropuser</code>, <code>createdb</code> e <code>dropdb</code> são atalhos convenientes equivalentes aos comandos do SQL. O novo usuário é bob com base de dados bobdb ; utilize a base de dados do super usuário como root com o pgsql:
<pre># createuser -U pgsql -P bob         <span class="cmt"># -P pedirá por senhar</span>
# createdb -U pgsql -O bob bobdb     <span class="cmt"># nova bobdb é propriedade de bob</span>
# dropdb bobdb                       <span class="cmt"># Exclui a base de dados bobdb</span>
# dropuser bob                       <span class="cmt"># Exclui o usuário bob</span>
</pre>
O mecanismo de autenticação da base de dados geral é configurado em pg_hba.conf
<h3>Conceder acesso remoto</h3>
O arquivo <code>$PGSQL_DATA_D/postgresql.conf</code> especifica em endereço a vinculá-lo. Tipicamente <code>listen_addresses = '*'</code> para Postgres 8.x.<br />
O arquivo <code>$PGSQL_DATA_D/pg_hba.conf</code> define o controle de acesso. Exemplos:
<pre># TYPE  DATABASE    USER        IP-ADDRESS        IP-MASK          METHOD
host    bobdb       bob        212.117.81.42     255.255.255.255   password
host    all         all        0.0.0.0/0                           password
</pre>
<h3>Fazer backup e restaurar</h3>
Os backups e restaurações são feitos com o usuário user pgsql ou postgres. Fazer backup e restaurar uma única base de dados:
<pre># pg_dump --clean dbname &gt; dbname_sql.dump
# psql dbname &lt; dbname_sql.dump
</pre>
Fazer backup e restorar toda a base de dados (incluindo usuários):
<pre># pg_dumpall --clean &gt; full.dump
# psql -f full.dump postgres
</pre>
Nesse caso a restauração é iniciada com a base de dados postgres que é melhor quando recarregar um cluster vazio.

<h2 id="mysql">MySQL</h2>
<h3>Alterar senha root ou do usuário do mysql</h3>
<h4>Método 1</h4>
<pre># /etc/init.d/mysql stop
<i><span class="cmt">ou</span></i>
# killall mysqld
# mysqld --skip-grant-tables
# mysqladmin -u root password 'newpasswd'
# /etc/init.d/mysql start
</pre>
<h4>Método 2</h4>
<pre># mysql -u root mysql
<span class="cmt">mysql&gt;</span> UPDATE USER SET PASSWORD=PASSWORD("newpassword") where user='root';
<span class="cmt">mysql&gt;</span> FLUSH PRIVILEGES;                           <span class="cmt"># Utilize username ao inves do "root"</span>
<span class="cmt">mysql&gt;</span> quit
</pre>
<h3>Cria usuário e base de dados (veja <a href="http://dev.mysql.com/doc/refman/5.1/en/adding-users.html">MySQL doc</a><span class="fn">http://dev.mysql.com/doc/refman/5.1/en/adding-users.html</span>)</h3>
<pre># mysql -u root mysql
<span class="cmt">mysql&gt;</span> CREATE USER 'bob'@'localhost' IDENTIFIED BY 'pwd'; <span class="cmt"># cria somente um usuário</span>
<span class="cmt">mysql&gt;</span> CREATE DATABASE bobdb;
<span class="cmt">mysql&gt;</span> GRANT ALL ON *.* TO 'bob'@'%' IDENTIFIED BY 'pwd'; <span class="cmt"># Utilize localhost ao inves de %</span>
                                                   <span class="cmt"># para limitar o acesso a rede</span>
<span class="cmt">mysql&gt;</span> DROP DATABASE bobdb;                        <span class="cmt"># Exclui base de dados</span>
<span class="cmt">mysql&gt;</span> DROP USER bob;                              <span class="cmt"># Exclui usuário</span>
<span class="cmt">mysql&gt;</span> DELETE FROM mysql.user WHERE user='bob and host='hostname'; <span class="cmt"># Alt. command</span>
<span class="cmt">mysql&gt;</span> FLUSH PRIVILEGES;
</pre>
<h3>Conceder acesso remoro</h3>
Acesso remoto é tipicamente permitido para uma base de dados, e não todas as bases de dados. O arquivo <code>/etc/my.cnf</code> contem o endereço IP a ser vinculado. (No FreeBSD <code>my.cnf</code> não criada por padrão, copie um arquivo <code>.cnf</code> de <code>/usr/local/share/mysql</code> para <code>/usr/local/etc/my.cnf</code>) Tipicamente comente a linha <code>bind-address =</code> out.
<pre># mysql -u root mysql
<span class="cmt">mysql&gt;</span> GRANT ALL ON bobdb.* TO bob@'xxx.xxx.xxx.xxx' IDENTIFIED BY 'PASSWORD';
<span class="cmt">mysql&gt;</span> REVOKE GRANT OPTION ON foo.* FROM bar@'xxx.xxx.xxx.xxx';
<span class="cmt">mysql&gt;</span> FLUSH PRIVILEGES;                  <span class="cmt"># Utilize 'hostname' ou também '%' para total acesso</span>
</pre>
<h3>realizar backup e restaurar</h3>
Backup e restaurar uma única base de dados:
<pre># mysqldump -u root -psecret --add-drop-database dbname &gt; dbname_sql.dump
# mysql -u root -psecret -D dbname &lt; dbname_sql.dump
</pre>
Realizar backup e restaurar toda a base de dados:
<pre># mysqldump -u root -psecret --add-drop-database --all-databases &gt; full.dump
# mysql -u root -psecret &lt; full.dump
</pre>
Aqui em "secret" é  a senha root do mysql, não há espaço depois do -p. Quando a opção -p é utilizada sosinha (w/o password), a seha é pergunatada no prompt de comando.

<h2 id="sqlite">SQLite</h2>
<a href="http://www.sqlite.org/">SQLite</a><span class="fn">http://www.sqlite.org</span> é uma base de dados SQL pequena e poderoza independente, sem servidor (serverless), e sem configuração (zero-configuration).
<h3>desepejar (Dump) e restaurar</h3>
Pode ser util desepejar e restaura uma base de dados SQLite. Por exemplo, você pode editar o arquivo dump para alterar um atributo de coluna ou tipe e depois restaurar a base de dados. Isso é mais fácil do que bagunçar com os comandos do SQL. Utilize o comando <code>sqlite3</code> para uma base de dados 3.x.
<pre># sqlite database.db .dump &gt; dump.sql              <span class="cmt"># dump</span>
# sqlite database.db &lt; dump.sql                    <span class="cmt"># restaura</span>
</pre>
<h3>Converter a base de dados do 2.x para a base de dados do 3.x</h3>
<pre>sqlite database_v2.db .dump | sqlite3 database_v3.db</pre>
</div>

<div id="quota"><h1><a>Quota de Disco</a></h1>
Uma quota de disco permite limitar a quantidade de espaço em disco e/ou o número de arquivos um usário (ou membros do grupo) podem usar. As quotas são alocadas em uma base de sistema per-file (por-arquivo) e são impostas pelo kernel.
<h2>Configuração no Linux</h2>
O pacote de ferramentas de quota geralmente precisa ser instalada, que contem ferramentas em linha de comando.<br />
Ative a quota de usuário no fstab e remonte a partição. Se a partição estiver ocupada, ou todos os arquivos bloqueados devem ser fechados, ou o sistem deve ser reiniciado. Adicione <code>usrquota</code> as opções do montagem do fstab, por exemplo:
<pre>/dev/sda2     /home    reiserfs     rw,acl,user_xattr,usrquota 1 1
# mount -o remount /home
# mount                              <span class="cmt"># Verifica se o usrquota está ativo, caso contrario reboot</span>
</pre>
Initialize the quota.user file with <code>quotacheck</code>.
<pre># quotacheck -vum /home
# chmod 644 /home/aquota.user        <span class="cmt"># Para deixar os usuários verificarem suas próprias quotas</span>
</pre>
Ativar a quota ou com o script fornecido (ex. /etc/init.d/quotad no SuSE) ou com o <code>quotaon</code>:
<pre>quotaon -vu /home</pre>
Verificar que a quota está ativa com o:
<pre>quota -v</pre>

<h2>Configuração no FreeBSD</h2>
As ferramentas de quota são parte do sistema base, no entando o kernel precisa  da opção quota. Se não estiver la, adicione e <a href="http://cb.vu/unixtoolbox.xhtml#compilekernel">recompile</a> o kernel.
<pre>options QUOTA</pre>
Assim como com o Linux, adicione a quota ás opções do fstab (userquota, não usrquota):
<pre>/dev/ad0s1d    /home    ufs     rw,noatime,userquota    2  2
# mount /home                        <span class="cmt"># Para remontar a partição</span>
</pre>
Abilita quatos de disco em /etc/rc.conf e inicia a quota.
<pre># grep quotas /etc/rc.conf
enable_quotas="YES"                  <span class="cmt"># lig quotas no startup (ou NO).</span>
check_quotas="YES"                   <span class="cmt"># Verfica quotas no startup (or NO).</span>
# /etc/rc.d/quota start
</pre>

<h2 id="assignquota">Atribuir limites de quota</h2>
As quota não são limitadas por padrão (defina a 0). Os limites são definidos com <code>edquota</code> por usuários. Uma quota podem ser duplicadas para muitos usuários.A estrutura de arquivo é diferente entra as implementações de quota, mas o principio é o mesmo: Os valores de blocos e inodes podem ser limitados. <i>Somente altere os valores do soft e hard</i>. Se não especificado, os blocos são de 1k. O grace period é definido com <code>edquota -t</code>. Por exemplo:
<pre># edquota -u colin</pre>
<h3>Linux</h3>
<pre>Quotas de disco para o usuário colin (uid 1007):
  Filesystem         blocks       soft       hard     inodes     soft     hard
  /dev/sda8            108       1000       2000          1        0        0
</pre>
<h3>FreeBSD</h3>
<pre>Quotas para os usuário colin:
/home: kbytes in use: 504184, limits (soft = 700000, hard = 800000)
   inodes in use: 1792, limits (soft = 0, hard = 0)
</pre>
<h3>Para muitos usuários</h3>
O comando <code>edquota -p</code> é usado para duplicar uma quota á putros usuários. Por exemplo, para duplicar uma quota de referencia a todos os usuários:
<pre># edquota -p refuser `awk -F: '$3 &gt; 499 {print $1}' /etc/passwd`
# edquota -p refuser user1 user2     <span class="cmt"># Duplicate to 2 users</span>
</pre>
<h3>Verificações</h3>
Usuários podem verificar suas quotas ao simplesmente digitar <code>quota</code> (o arquivo quota.user deve ser legivel). O root pode verificar todas as quotas.
<pre># quota -u colin                     <span class="cmt"># Verfifica quota para um usuário</span>
# repquota /home                     <span class="cmt"># relatório total para a partição (para todos os usuários nesse caso)</span>
</pre>
</div>

<div id="shells"><h1><a>Shells</a></h1>
Muitas distribuições Linux utilizam o shell bash enquanto os BSDs utilizam o tcsh, o bourne shell é utilizado somente para scripts. Filtros são muito uteis e pode ser canalizados:
<ul style="list-style-type:none;">
  <li><code>grep</code>   Parametro de combinação</li>
  <li><code>sed</code>   Busca e substitui strings ou caracteres</li>
  <li><code>cut</code>   Imprime colunas específicas a partir de um marcador</li>
  <li><code>sort</code>   Ordena alfabeticamente ou numericamente</li>
  <li><code>uniq</code>   Remove linhas duplicadas de um arquivo</li>
</ul>
Utilizados todos de uma so vez por exemplo:
<pre># ifconfig | sed 's/  / /g' | cut -d" " -f1 | uniq | grep -E "[a-z0-9]+" | sort -r
# ifconfig | sed '/.*inet addr:/!d;s///;s/ .*//'|sort -t. -k1,1n -k2,2n -k3,3n -k4,4n
</pre>
O primeiro caracter no parâmetro do sed é uma guia. Para escrever uma guia no console, utilize ctrl-v ctrl-tab.

<h2 id="bash">bash</h2>
Redireciona e canaliza para o bash e para o sh:
<pre># cmd 1&gt; file                         <span class="cmt"># Redireciona a saída padrão (stdout) para o arquivo.</span>
# cmd 2&gt; file                         <span class="cmt"># Redirecia erro padão (stderr) para o arquivo.</span>
# cmd 1&gt;&gt; file                        <span class="cmt"># Redireciona e anexa saída padrão para o arquivo.</span>
# cmd &amp;&gt; file                         <span class="cmt"># Redireciona ambas (stdout e stderr) para o arquivo.</span>
# cmd &gt;file 2&gt;&amp;1                      <span class="cmt"># Redireciona erro padrão para saída padrão e depois para o arquivo.</span>
# cmd1 | cmd2                         <span class="cmt"># canaliza saída padrão para cmd2</span>
# cmd1 2&gt;&amp;1 | cmd2                    <span class="cmt"># canaliza stdout e stderr para o cmd2</span>
</pre>
Modificar sua configuração em ~/.bashrc (pode ser também ~/.bash_profile). As seguintes entradas são uteis, recarrega com ". .bashrc". Com o cygwin utilize ~/.bash_profile; com o rxvt cole com o shift + left-click.
<pre style="page-break-inside:avoid;"># in .bashrc
bind '"\e[A"':history-search-backward <span class="cmt"># Utiliza cetas para cima e para baixo para busca</span>
bind '"\e[B"':history-search-forward  <span class="cmt"># O history. Inastimável!</span>
set -o emacs                          <span class="cmt"># Define o modo emacs no (veja abaixo)</span>
set bell-style visible                <span class="cmt"># Não bipa, inverte cores</span>
    <span class="cmt"># Define um propt agradavel como [user@host]/path/todir&gt;</span>
PS1="\[\033[1;30m\][\[\033[1;34m\]\u\[\033[1;30m\]"
PS1="$PS1@\[\033[0;33m\]\h\[\033[1;30m\]]\[\033[0;37m\]"
PS1="$PS1\w\[\033[1;30m\]&gt;\[\033[0m\]"
</pre><pre><span class="cmt"># Para verificar os apelidos (aliases) ativos atualmente, simplesmente digite alias</span>
alias  ls='ls -aF'                    <span class="cmt"># Anexa indicador (um de */=&gt;@|)</span>
alias  ll='ls -aFls'                  <span class="cmt"># Listar</span>
alias  la='ls -all'
alias ..='cd ..'
alias ...='cd ../..'
export HISTFILESIZE=5000              <span class="cmt"># History maior</span>
export CLICOLOR=1                     <span class="cmt"># Utiliza cores (se possivel)</span>
export LSCOLORS=ExGxFxdxCxDxDxBxBxExEx
</pre>

<h2 id="tcsh">tcsh</h2>
Redirecionar e canlizar para o tcsh e o csh (simples &gt; e &gt;&gt; são os mesmo que no sh):
<pre># cmd &gt;&amp; file                         <span class="cmt"># Redireciona ambos os padrões (stdout e stderr) para o arquivo.</span>
# cmd &gt;&gt;&amp; file                        <span class="cmt"># Uni ambos os padrões (stdout e stderr) para o arquivo.</span>
# cmd1 | cmd2                         <span class="cmt"># canaliza a saída padrão para o cmd2</span>
# cmd1 |&amp; cmd2                        <span class="cmt"># canaliza saída padrão e de erro para o to cmd2</span>
</pre>

As configurações para o csh/tcsh são definidas em <code>~/.cshrc</code>, recarregam com o "source .cshrc". Exemplos:
<pre style="page-break-inside:avoid;"># in .cshrc
alias  ls      'ls -aF'
alias  ll      'ls -aFls'
alias  la      'ls -all'
alias  ..      'cd ..'
alias  ...     'cd ../..'
set   prompt    = "%B%n%b@%B%m%b%/&gt; " <span class="cmt"># como user@host/path/todir&gt;</span>
set   history   =  5000
set   savehist  = ( 6000 merge )
set   autolist                        <span class="cmt"># Reporta possíveis conclusões com tab</span>
set   visiblebell                     <span class="cmt"># Não bipa, inverte cores</span>
</pre><pre><span class="cmt"># Bindkey and colors</span>
bindkey -e     Select Emacs bindings  <span class="cmt"># Utiliza chaves do emacs para editar o prompt de comando</span>
bindkey -k up history-search-backward <span class="cmt"># Utilize cetas para cima e para baixo para busca</span>
bindkey -k down history-search-forward
setenv CLICOLOR 1                     <span class="cmt"># Utiliza cores (se possível)</span>
setenv LSCOLORS ExGxFxdxCxDxDxBxBxExEx
</pre>
O modo do emacs abilita para uso das chaves de atalhos do emacs para modificar o prompt de linha de comando. Isso é extremamente util (não somente para usuários do emacs). O comandos mais utilizados são:
<ul style="list-style-type:none;">
  <li>C-a       Move o cursor para o inicio da linha</li>
  <li>C-e       Move o cursor para o final da linha</li>
  <li>M-b       Move o cursor uma palavra de volta</li>
  <li>M-f       Move o cursor uma palavra a frente</li>
  <li>M-d       Corta a próxima palavra</li>
  <li>C-w       Corta a ultima palavra</li>
  <li>C-u       Corta tudo antes do cursor</li> 
  <li>C-k       Corta tudo depois do cursor (o resto da linha)</li>
  <li>C-y       Cola a ultima coisa cortada (simplesmente cola)</li>
  <li>C-_       Desfaz</li>
</ul>
<i>Nota:</i> C- = precione control, M- = precione meta (que geralmente é o alt ou a tecla escape).
</div>

<div id="scripting"><h1><a>Scripting</a></h1>
<p class="xrefp"><a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#bournebasics">Basicos</a> | <a class="xrefp" href="./Unix Toolbox_files/Unix Toolbox.xhtml">Script example</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#awk">awk</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#sed">sed</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#regex">Expressões Regulares</a> | <a class="xrefp" href="http://cb.vu/unixtoolbox.xhtml#shcmd">comandos uteis</a></p>
O shell Bourne (/bin/sh) está presente em todas as instalações Unix e  scripts escritos nessa linguagem são (bastante) portáveis; <code>man 1 sh</code> é uma boa referencia.

<h2 id="bournebasics">Basicos</h2>
<h3>Variaveis e argumentos</h3>
Atribui com variável=valor e obtem o conteúdo com $variável
<pre>MESSAGE="Hello World"                        <span class="cmt"># Atribui uma string</span>
PI=3.1415                                    <span class="cmt"># Atribui um número decimal</span>
N=8
TWON=`expr $N * 2`                           <span class="cmt"># Expressão aritmetica (somente números inteiros)</span>
TWON=$(($N * 2))                             <span class="cmt"># Outra syntax</span>
TWOPI=`echo "$PI * 2" | bc -l`               <span class="cmt"># Utiliza o bc para operações de ponto flutuante</span>
ZERO=`echo "c($PI/4)-sqrt(2)/2" | bc -l`
</pre>
Os argumentos de linha de comando
<pre>$0, $1, $2, ...                              <span class="cmt"># $0 é o comnado em si</span> 
$#                                           <span class="cmt"># O número de argumentos</span>
$*                                           <span class="cmt"># Todos os argumentos (também $@)</span>
</pre>
<h3>Variáveis especiais</h3>
<pre>$$                                           <span class="cmt"># O ID do processo atual</span>
$?                                           <span class="cmt"># sai do status do ultimo comando</span>
  command
  <span class="keyword">if</span> [ $<span class="pp">?</span> != 0 ]; <span class="keyword">then</span>
    echo "command failed"
  <span class="keyword">fi</span>
<span class="pp">mypath</span>=`pwd`
<span class="pp">mypath</span>=${<span class="pp">mypath</span>}/file.txt
echo ${<span class="pp">mypath</span>##*/}                           <span class="cmt"># Exibe o filename somente</span>
echo ${<span class="pp">mypath</span>%%.*}                           <span class="cmt"># Caminho completo sem extenção</span>
foo=/tmp/my.dir/filename.tar.gz
path = ${foo%/*}                             <span class="cmt"># Caminho completo sem extenção</span>
<span class="pp">var2</span>=${<span class="pp">var</span>:=string}                          <span class="cmt"># Utiliza var se definido, caso contrario utiliza string
                                             # atribui string para var e depois para var2.</span>
size=$(stat -c%s "$file")                    <span class="cmt"># obtem tamanho do arquivo no script bourne</span>
filesize=${size:=-1}
</pre>

<h3>Constructs</h3>
<pre><span class="keyword">for</span> <span class="pp">file</span> in `ls`
<span class="keyword">do</span>
    echo $<span class="pp">file</span>
<span class="keyword">done</span>

<span class="pp">count</span>=0
<span class="keyword">while</span> [ $<span class="pp">count</span> -lt 5 ]; <span class="keyword">do</span>
    echo $<span class="pp">count</span>
    sleep 1
    <span class="pp">count</span>=$(($<span class="pp">count</span> + 1))
<span class="keyword">done</span>

myfunction() {
    find . -type f -name "*.$<span class="pp">1</span>" -print       <span class="cmt"># $1 é o primeiro argumento da função</span>
}
myfunction "txt"
</pre>
<h4>Gerar um arquivo</h4>
<pre><span class="pp">MYHOME</span>=/home/colin
cat &gt; testhome.sh &lt;&lt; _EOF
<span class="cmt"># Tudo isso vai para dentro do arquivo testhome.sh</span>
<span class="keyword">if</span> [ -d "$<span class="pp">MYHOME</span>" ] ; <span class="keyword">then</span>
    echo $<span class="pp">MYHOME</span> exists
<span class="keyword">else</span>
    echo $<span class="pp">MYHOME</span> does not exist
<span class="keyword">fi</span>
_EOF
sh testhome.sh
</pre>
<h2 id="bourneexample">Exemplos de script Bourne</h2>
Com um pequeno exemplo, o script utilizado para gerar um livreto PDF a partir desse documento xhtml:
<pre style="page-break-inside:avoid;"><span class="pp">#!/bin/sh</span>
<span class="cmt"># Esse script gera um livre em formato pdf pronto para imprimir em uma impressora duplex</span>
<span class="keyword">if</span> [ $<span class="pp">#</span> <span class="keyword">-ne</span> 1 ]; <span class="keyword">then</span>                        <span class="cmt"># Verifica o argumento</span>
  echo 1&gt;&amp;2 "Usage: $0 HtmlFile"
  <span class="keyword">exit</span> 1                                     <span class="cmt"># sai diferente de zero se der erro</span>
<span class="keyword">fi</span>

<span class="pp">file</span>=$<span class="pp">1</span>                                      <span class="cmt"># Atribui o filename</span>
<span class="pp">fname</span>=${<span class="pp">file</span>%.*}                             <span class="cmt"># Obtem o nome do arquivo somente</span>
<span class="pp">fext</span>=${<span class="pp">file</span>#*.}                              <span class="cmt"># Obtem a extensão do arqvuivo</span>

prince $<span class="pp">file</span> -o $<span class="pp">fname</span>.pdf                   <span class="cmt"># Do www.princexml.com</span>
pdftops -paper A4 -noshrink $<span class="pp">fname</span>.pdf $<span class="pp">fname</span>.ps <span class="cmt"># gera livreto postscript</span>
cat $<span class="pp">fname</span>.ps |psbook|psnup -Pa4 -2 |pstops -b "2:0,1U(21cm,29.7cm)" &gt; $<span class="pp">fname</span>.book.ps

ps2pdf13 -sPAPERSIZE=a4 -sAutoRotatePages=None $<span class="pp">fname</span>.book.ps $<span class="pp">fname</span>.book.pdf
                                             <span class="cmt"># utliza #a4 e #Nenhum no Windows!</span>
<span class="keyword">exit</span> 0                                       <span class="cmt"># sair 0 significa sucesso</span>
</pre>

<h2 id="awk">Alguns comandos awk</h2>
Awk é util para field stripping, como cortar de um jeito mais poderoso. Busque esse documento para outros exemplos. Veja por exemplo <a href="http://www.gnulamp.com/awk.html">gnulamp.com</a> e <a href="http://student.northpark.edu/pemente/awk/awk1line.txt">one-liners for awk</a> para mais bons exemplos.
<pre>awk '{ print $2, $1 }' file                  <span class="cmt"># Imprime e inverte as primeiras duas colunas</span>
awk '{printf("%5d : %s\n", NR,$0)}' file     <span class="cmt"># Adiciona números alinhados a esquerda</span>
awk '{print FNR "\t" $0}' files              <span class="cmt"># Adiciona números alinhados a direita</span>
awk NF test.txt                              <span class="cmt"># remove linhas em branco (o mesmo que grep '.')</span>
awk 'length &gt; 80'                            <span class="cmt"># imprime linha maios que 80 caracteres)</span>
</pre>

<h2 id="sed">Alguns comandos sed</h2>
Aqui está <a href="http://student.northpark.edu/pemente/sed/sed1line.txt">a mina de ouro</a><span class="fn">http://student.northpark.edu/pemente/sed/sed1line.txt</span>. E uma boa <a href="http://www.grymoire.com/Unix/Sed.html">introdução e tutorial ao sed</a><span class="fn">http://www.grymoire.com/Unix/Sed.html</span>.
<pre>sed 's/string1/string2/g'                    <span class="cmt"># Substitue string1 com string2</span>
sed -i 's/wroong/wrong/g' *.txt              <span class="cmt"># Substitue uma palavra recorrente com g</span>
sed 's/\(.*\)1/\12/g'                        <span class="cmt"># Modifica anystring1 para anystring2</span>
sed '/&lt;p&gt;/,/&lt;\/p&gt;/d' t.xhtml                 <span class="cmt"># Exclui linhas que iniciam com &lt;p&gt;</span>
                                             <span class="cmt"># e terminam com &lt;/p&gt;</span>
sed '/ *#/d; /^ *$/d'                        <span class="cmt"># Remove comentários e linha em branco</span>
sed 's/[ \t]*$//'                            <span class="cmt"># Remove trailing espaces (utilize tab como \t)</span>
sed 's/^[ \t]*//;s/[ \t]*$//'                <span class="cmt"># Remove leading e trailing spaces</span>
sed 's/[^*]/[&amp;]/'                            <span class="cmt"># Cerca primeiro caractere com [] top-&gt;[t]op</span>
sed = file | sed 'N;s/\n/\t/' &gt; file.num     <span class="cmt"># Numera linhas em um arquivo</span>
</pre>

<h2 id="regex">Expressões regulares</h2>
Algumas expressões regulares básicas uteis para o sed também. Veja <a href="http://www.regular-expressions.info/reference.html">Syntax Regex Básicas</a><span class="fn">http://www.regular-expressions.info/reference.html</span> para uma boa impressão.
<pre>[\^$.|?*+()                          <span class="cmt"># caracteres speciais, qualquer outros combinarão entre sim</span>
\                                    <span class="cmt"># ignora carateres speciais e trata-os como literais</span>
*                                    <span class="cmt"># repete o item anterior zero ou mais vezes</span>
.                                    <span class="cmt"># unico caracter exceto caracteres de quebra de linha</span>
.*                                   <span class="cmt"># combina zero ou mais caracteres</span>
^                                    <span class="cmt"># combina no inicio de uma linha/string</span>
$                                    <span class="cmt"># combina o final de uma linha/string</span>
.$                                   <span class="cmt"># combina um único caracter no dinal da linha/string</span>
^ $                                  <span class="cmt"># combina linha com um unico espaço</span>
[^A-Z]                               <span class="cmt"># combina qualquer linha iniciada com qualquer caracter de A to Z</span>
</pre>

<h2 id="shcmd">Alguns comandos uteis</h2>
O comandos a seguir são uteis para incluir em um script ou como um liners.
<pre>sort -t. -k1,1n -k2,2n -k3,3n -k4,4n         <span class="cmt"># Ordena endereço de ip IPv4</span>
echo 'Test' | tr '[:lower:]' '[:upper:]'     <span class="cmt"># Conversão de Case conversion</span>
echo foo.bar | cut -d . -f 1                 <span class="cmt"># Retorna foo</span>
PID=$(ps | grep script.sh | grep bin | awk '{print $1}')    <span class="cmt"># PID de um script em execução</span>
PID=$(ps axww | grep [p]ing | awk '{print $1}')             <span class="cmt"># PID do ping (w/o grep pid)</span>
IP=$(ifconfig $INTERFACE | sed '/.*inet addr:/!d;s///;s/ .*//')   <span class="cmt"># Linux</span>
IP=$(ifconfig $INTERFACE | sed '/.*inet /!d;s///;s/ .*//')        <span class="cmt"># FreeBSD</span>
if [ `diff file1 file2 | wc -l` != 0 ]; then [...] fi       <span class="cmt"># Arquivo alterado?</span>
cat /etc/master.passwd | grep -v root | grep -v \*: | awk -F":" \ <span class="cmt"># Gera http passwd</span>
'{ printf("%s:%s\n", $1, $2) }' &gt; /usr/local/etc/apache2/passwd

testuser=$(cat /usr/local/etc/apache2/passwd | grep -v \    <span class="cmt"># Verifica usuário em passwd</span>
root | grep -v \*: | awk -F":" '{ printf("%s\n", $1) }' | grep ^user$)
:(){ :|:&amp; };:                                <span class="cmt"># bash fork bomb. Vai matar a sua máquina</span>
tail +2 file &gt; file2                         <span class="cmt"># remove a primeira linha do arquivo</span>
</pre>
I utilizo esse truque para alterar a extenção do arquivo para muitos arquivos de uma vez. Por exemplo de .cxx para .cpp. Testa-o ante sem o <code>| sh</code> no final. Você pode tambem fazer isso com o comando <code>rename</code> se instalado. Ou com o bash builtins.
<pre># ls *.cxx | awk -F. '{print "mv "$0" "$1".cpp"}' | sh
# ls *.c | sed "s/.*/cp &amp; &amp;.$(date "+%Y%m%d")/" | sh <span class="cmt"># ex. copia *.c para *.c.20080401</span>
# rename .cxx .cpp *.cxx                             <span class="cmt"># Renomeia todos os .cxx para o cpp</span>
# for i in *.cxx; do mv $i ${i%%.cxx}.cpp; done      <span class="cmt"># com o bash builtins</span>
</pre>
</div>

<div id="programming"><h1><a>Programação</a></h1>
<h2 id="cbasics">Basicos de C</h2>
<pre>strcpy(newstr,str)                        <span class="cmt">/* copia str para newstr */</span>
expr1 ? expr2 : expr3                     <span class="cmt">/* if (expr1) expr2 else expr3 */</span>
x = (y &gt; z) ? y : z;                      <span class="cmt">/* if (y &gt; z) x = y; else x = z; */</span>
int a[]={0,1,2};                          <span class="cmt">/* Array inicializada (ou a[3]={0,1,2}; */</span>
int a[2][3]={{1,2,3},{4,5,6}};            <span class="cmt">/* Array de array de ints */</span>
int i = 12345;                            <span class="cmt">/* Converte de i para char str */</span>
char str[10];
sprintf(str, "%d", i);
</pre>
<h2>Exemplo de C</h2>
Um programa c mínimo simple.c:
<pre><span class="pp">#include</span> &lt;stdio.h&gt;
main() {
    <span class="keyword">int</span> number=42;
    printf("The answer is %i\n", number);  
}
</pre>
Compile com o:
<pre># gcc simple.c -o simple
# ./simple
The answer is 42
</pre>

<h2 id="cppbasics">Básicas do C++</h2>
<pre>*pointer                                  <span class="cmt">// Objeto apontado pelo apontador</span>
&amp;obj                                      <span class="cmt">// Endereço do objeto obj</span>
obj.x                                     <span class="cmt">// Membro x da classe obj (objeto obj)</span>
pobj-&gt;x                                   <span class="cmt">// Membro x da classe apontado para pobj</span>
                                          <span class="cmt">// (*pobj).x e pobj-&gt;x são os mesmos</span>
</pre>
<h2>Exemplo de C++</h2>
Como um programa ligeiramete mais realitico em C++: uma classe em seu próprio header (IPv4.h) e implementação (IPv4.cpp) e um programa que utiliza a funcionalidade da classe. A classe converte um endereço de IP em formato integer para o formato quad conhecido.
<h3>Classe IPv4</h3>
<h4>IPv4.h:</h4>
<pre style="page-break-inside:avoid;"><span class="pp">#ifndef</span> IPV4_H
<span class="pp">#define</span> IPV4_H
<span class="pp">#include</span> &lt;string&gt;

<span class="keyword">namespace</span> GenericUtils {                          <span class="cmt">// gera um namespace
</span><span class="keyword">class</span> IPv4 {                                      <span class="cmt">// definição de classe
</span><span class="keyword">public</span>:
    IPv4(); ~IPv4();
    std::string IPint_to_IPquad(<span class="keyword">unsigned</span> <span class="keyword">long</span> ip);<span class="cmt">// interface membro
</span>};
} <span class="cmt">//namespace GenericUtils</span>
<span class="pp">#endif</span> <span class="cmt">// IPV4_H
</span></pre>

<h4>IPv4.cpp:</h4>
<pre style="page-break-inside:avoid;"><span class="pp">#include</span> "IPv4.h"
<span class="pp">#include</span> &lt;string&gt;
<span class="pp">#include</span> &lt;sstream&gt;
<span class="keyword">using</span> <span class="keyword">namespace</span> std;                              <span class="cmt">// utiliza os namespaces
</span><span class="keyword">using</span> <span class="keyword">namespace</span> GenericUtils;

IPv4::IPv4() {}                                   <span class="cmt">// construtor/destrutor padrão
</span>IPv4::~IPv4() {}
string IPv4::IPint_to_IPquad(<span class="keyword">unsigned</span> <span class="keyword">long</span> ip) {  <span class="cmt">// implementação membro
</span>    ostringstream ipstr;                          <span class="cmt">// utiliza uma stringstream
</span>    ipstr &lt;&lt; ((ip &amp;0xff000000) &gt;&gt; 24)             <span class="cmt">// Bitwise right shift
</span>          &lt;&lt; "." &lt;&lt; ((ip &amp;0x00ff0000) &gt;&gt; 16)
          &lt;&lt; "." &lt;&lt; ((ip &amp;0x0000ff00) &gt;&gt; 8)
          &lt;&lt; "." &lt;&lt; ((ip &amp;0x000000ff));
    <span class="keyword">return</span> ipstr.str();
}
</pre>
<h3>o programa simplecpp.cpp</h3>
<pre style="page-break-inside:avoid;"><span class="pp">#include</span> "IPv4.h"
<span class="pp">#include</span> &lt;iostream&gt;
<span class="pp">#include</span> &lt;string&gt;
<span class="keyword">using</span> <span class="keyword">namespace</span> std;
<span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[]) {
    string ipstr;                                 <span class="cmt">// define variaveis
</span>    <span class="keyword">unsigned</span> <span class="keyword">long</span> ipint = 1347861486;             <span class="cmt">// O IP em forma integer</span>
    GenericUtils::IPv4 iputils;                   <span class="cmt">// gera um objeto da classe
</span>    ipstr = iputils.IPint_to_IPquad(ipint);       <span class="cmt">// chama a classe membro
</span>    cout &lt;&lt; ipint &lt;&lt; " = " &lt;&lt; ipstr &lt;&lt; endl;      <span class="cmt">// imprime o resultado</span>

    <span class="keyword">return</span> 0;
}
</pre>

Compile e execute com:
<pre style="page-break-before:avoid;"># g++ -c IPv4.cpp simplecpp.cpp                <span class="cmt"># Compile em objetos</span>
# g++ IPv4.o simplecpp.o -o simplecpp.exe      <span class="cmt"># Linka os objetos para o executavel final</span>
# ./simplecpp.exe 
1347861486 = 80.86.187.238
</pre>
Utilize <code>ldd</code> para verificar que bibliotecas são utilizadas pelo executavel e aonde eles ficam localizados. utilize tambem para verificar se uma biblioteca compartilhada está faltando ou se o executavel é estático.
<pre># ldd /sbin/ifconfig                           <span class="cmt"># lista dependências de objeto dinâmico</span>
# ar rcs staticlib.a *.o                       <span class="cmt"># gera arquivo estático</span>
# ar t staticlib.a                             <span class="cmt"># imprime a lista de objetos do arquivo</span>
# ar x /usr/lib/libc.a version.o               <span class="cmt"># extrai um objeto arquivo</span>
# nm version.o                                 <span class="cmt"># Exibe membros de função fornecidas pelo objeto</span>
</pre>
<h2 id="makefile">Simples Makefile</h2>
O Makefile mínimo para o programa multi-source é exibido abaixo. As lihas com instruções <i>devem iniciar com um tab</i>! A bara invertida (back slash) "\" pode ser utilizada para cortar linhas longas.
<pre style="page-break-inside:avoid;"><span class="pp">CC</span> = g++
<span class="pp">CFLAGS</span> = -O
<span class="pp">OBJS</span> = IPv4.o simplecpp.o

<span class="keyword">simplecpp</span>: ${OBJS}
	${CC} -o simplecpp ${CFLAGS} ${OBJS}
<span class="keyword">clean</span>:
	rm -f ${TARGET} ${OBJS}
</pre>
</div>

<div id="onlinehelp"><h1><a> Ajuda online</a></h1>
<h2 id="documentation">Documentação</h2>
<table>
  <tr><td><a href="http://en.tldp.org/">Linux Documentation</a> </td><td>en.tldp.org</td></tr>
  <tr><td><a href="http://www.linuxmanpages.com/">Linux Man Pages</a> </td><td>www.linuxmanpages.com</td></tr>
  <tr><td><a href="http://www.oreillynet.com/linux/cmd/">Linux commands directory</a> </td><td>www.oreillynet.com/linux/cmd</td></tr>
  <tr><td><a href="http://linux.die.net/">Linux doc man howtos</a> </td><td>linux.die.net</td></tr>
  <tr><td><a href="http://www.freebsd.org/handbook/">FreeBSD Handbook</a> </td><td>www.freebsd.org/handbook</td></tr>
  <tr><td><a href="http://www.freebsd.org/cgi/man.cgi">FreeBSD Man Pages</a> </td><td>www.freebsd.org/cgi/man.cgi</td></tr>
  <tr><td><a href="http://www.freebsdwiki.net/">FreeBSD user wiki</a> </td><td>www.freebsdwiki.net</td></tr>
  <tr><td><a href="http://docs.sun.com/app/docs/coll/40.10">Solaris Man Pages</a> </td><td>docs.sun.com/app/docs/coll/40.10</td></tr>
</table>
<h2 id="crossref">Outra referências Unix/Linux</h2>
<table>
  <tr><td><a href="http://bhami.com/rosetta.html">Rosetta Stone for Unix</a> </td><td>bhami.com/rosetta.html (a Unix command translator)</td></tr>
  <tr><td><a href="http://unixguide.net/unixguide.shtml">Unix guide cross reference</a> </td><td>unixguide.net/unixguide.shtml</td></tr>
  <tr><td><a rel="nofollow" href="http://www.linuxcmd.org/">Linux commands line list</a> </td><td>www.linuxcmd.org</td></tr>
  <tr><td><a rel="nofollow" href="http://www.pixelbeat.org/cmdline.html">Short Linux reference</a> </td><td>www.pixelbeat.org/cmdline.html</td></tr>
  <tr><td><a href="http://www.shell-fu.org/">Little command line goodies</a> </td><td>www.shell-fu.org</td></tr>
</table>
</div>

<p class="last">Isso é tudo pessoal!</p>

<!-- page break -->
<!-- <div class="pb" /> -->

<div class="footerlast">
This document: "Unix Toolbox revisão 14.4" está licesiada sob a <a rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Licence [Attribution - Share Alike]</a>. © <a href="mailto:c_at_cb.vu">Colin Barschel</a> 2007-2012. Alguns direitos reservados. Traduzido por Gabriel da Silveira Costa.
</div>

</body>
</html>
